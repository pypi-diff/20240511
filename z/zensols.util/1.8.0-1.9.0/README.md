# Comparing `tmp/zensols.util-1.8.0-py3-none-any.whl.zip` & `tmp/zensols.util-1.9.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,58 +1,59 @@
-Zip file size: 141281 bytes, number of entries: 56
--rw-rw-r--  2.0 unx      491 b- defN 22-May-04 21:11 zensols/cli/__init__.py
--rw-rw-r--  2.0 unx    23762 b- defN 22-May-04 21:11 zensols/cli/action.py
--rw-rw-r--  2.0 unx    28917 b- defN 22-May-04 21:11 zensols/cli/app.py
--rw-rw-r--  2.0 unx    18042 b- defN 22-May-04 21:11 zensols/cli/cmd.py
--rw-rw-r--  2.0 unx    19026 b- defN 22-May-04 21:11 zensols/cli/harness.py
--rw-rw-r--  2.0 unx    10205 b- defN 22-May-04 21:11 zensols/cli/meta.py
--rw-rw-r--  2.0 unx    14051 b- defN 22-May-04 21:11 zensols/cli/peraction.py
--rw-rw-r--  2.0 unx     9544 b- defN 22-May-04 21:11 zensols/cli/simple.py
--rw-rw-r--  2.0 unx    15285 b- defN 22-May-04 21:11 zensols/cli/usage.py
--rw-rw-r--  2.0 unx      996 b- defN 22-May-04 21:11 zensols/cli/util.py
--rw-rw-r--  2.0 unx    16835 b- defN 22-May-04 21:11 zensols/cli/lib/config.py
--rw-rw-r--  2.0 unx     5577 b- defN 22-May-04 21:11 zensols/cli/lib/log.py
--rw-rw-r--  2.0 unx     3265 b- defN 22-May-04 21:11 zensols/cli/lib/package.py
--rw-rw-r--  2.0 unx    11964 b- defN 22-May-04 21:11 zensols/cli/lib/support.py
--rw-rw-r--  2.0 unx      665 b- defN 22-May-04 21:11 zensols/config/__init__.py
--rw-rw-r--  2.0 unx    11665 b- defN 22-May-04 21:11 zensols/config/configbase.py
--rw-rw-r--  2.0 unx     5247 b- defN 22-May-04 21:11 zensols/config/configfac.py
--rw-rw-r--  2.0 unx    10733 b- defN 22-May-04 21:11 zensols/config/dictable.py
--rw-rw-r--  2.0 unx     3120 b- defN 22-May-04 21:11 zensols/config/dictconfig.py
--rw-rw-r--  2.0 unx     1987 b- defN 22-May-04 21:11 zensols/config/diff.py
--rw-rw-r--  2.0 unx     4043 b- defN 22-May-04 21:11 zensols/config/envconfig.py
--rw-rw-r--  2.0 unx    25934 b- defN 22-May-04 21:11 zensols/config/factory.py
--rw-rw-r--  2.0 unx    21081 b- defN 22-May-04 21:11 zensols/config/importini.py
--rw-rw-r--  2.0 unx     4124 b- defN 22-May-04 21:11 zensols/config/importyaml.py
--rw-rw-r--  2.0 unx    13128 b- defN 22-May-04 21:11 zensols/config/iniconfig.py
--rw-rw-r--  2.0 unx     2737 b- defN 22-May-04 21:11 zensols/config/json.py
--rw-rw-r--  2.0 unx     2760 b- defN 22-May-04 21:11 zensols/config/keychain.py
--rw-rw-r--  2.0 unx     6857 b- defN 22-May-04 21:11 zensols/config/meta.py
--rw-rw-r--  2.0 unx    11955 b- defN 22-May-04 21:11 zensols/config/serial.py
--rw-rw-r--  2.0 unx     2996 b- defN 22-May-04 21:11 zensols/config/strconfig.py
--rw-rw-r--  2.0 unx     7175 b- defN 22-May-04 21:11 zensols/config/writable.py
--rw-rw-r--  2.0 unx     7171 b- defN 22-May-04 21:11 zensols/config/writeback.py
--rw-rw-r--  2.0 unx     9531 b- defN 22-May-04 21:11 zensols/config/yaml.py
--rw-rw-r--  2.0 unx      126 b- defN 22-May-04 21:11 zensols/introspect/__init__.py
--rw-rw-r--  2.0 unx     6335 b- defN 22-May-04 21:11 zensols/introspect/imp.py
--rw-rw-r--  2.0 unx    16097 b- defN 22-May-04 21:11 zensols/introspect/inspect.py
--rw-rw-r--  2.0 unx      123 b- defN 22-May-04 21:11 zensols/multi/__init__.py
--rw-rw-r--  2.0 unx    13321 b- defN 22-May-04 21:11 zensols/multi/stash.py
--rw-rw-r--  2.0 unx      354 b- defN 22-May-04 21:11 zensols/persist/__init__.py
--rw-rw-r--  2.0 unx    20138 b- defN 22-May-04 21:11 zensols/persist/annotation.py
--rw-rw-r--  2.0 unx     9142 b- defN 22-May-04 21:11 zensols/persist/composite.py
--rw-rw-r--  2.0 unx     8829 b- defN 22-May-04 21:11 zensols/persist/dealloc.py
--rw-rw-r--  2.0 unx    19042 b- defN 22-May-04 21:11 zensols/persist/domain.py
--rw-rw-r--  2.0 unx     5327 b- defN 22-May-04 21:11 zensols/persist/shelve.py
--rw-rw-r--  2.0 unx    11521 b- defN 22-May-04 21:11 zensols/persist/stash.py
--rw-rw-r--  2.0 unx      362 b- defN 22-May-04 21:11 zensols/util/__init__.py
--rw-rw-r--  2.0 unx     3131 b- defN 22-May-04 21:11 zensols/util/executor.py
--rw-rw-r--  2.0 unx     5479 b- defN 22-May-04 21:11 zensols/util/log.py
--rw-rw-r--  2.0 unx     2934 b- defN 22-May-04 21:11 zensols/util/pkgres.py
--rw-rw-r--  2.0 unx      916 b- defN 22-May-04 21:11 zensols/util/std.py
--rw-rw-r--  2.0 unx     3343 b- defN 22-May-04 21:11 zensols/util/tempfile.py
--rw-rw-r--  2.0 unx     5726 b- defN 22-May-04 21:11 zensols/util/time.py
--rw-rw-r--  2.0 unx     7521 b- defN 22-May-04 21:11 zensols.util-1.8.0.dist-info/METADATA
--rw-rw-r--  2.0 unx       92 b- defN 22-May-04 21:11 zensols.util-1.8.0.dist-info/WHEEL
--rw-rw-r--  2.0 unx       89 b- defN 22-May-04 21:11 zensols.util-1.8.0.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     4552 b- defN 22-May-04 21:11 zensols.util-1.8.0.dist-info/RECORD
-56 files, 475369 bytes uncompressed, 134191 bytes compressed:  71.8%
+Zip file size: 142910 bytes, number of entries: 57
+-rw-rw-r--  2.0 unx      491 b- defN 22-May-15 16:23 zensols/cli/__init__.py
+-rw-rw-r--  2.0 unx    23762 b- defN 22-May-15 16:23 zensols/cli/action.py
+-rw-rw-r--  2.0 unx    28917 b- defN 22-May-15 16:23 zensols/cli/app.py
+-rw-rw-r--  2.0 unx    18042 b- defN 22-May-15 16:23 zensols/cli/cmd.py
+-rw-rw-r--  2.0 unx    19026 b- defN 22-May-15 16:23 zensols/cli/harness.py
+-rw-rw-r--  2.0 unx    10205 b- defN 22-May-15 16:23 zensols/cli/meta.py
+-rw-rw-r--  2.0 unx    14051 b- defN 22-May-15 16:23 zensols/cli/peraction.py
+-rw-rw-r--  2.0 unx     9544 b- defN 22-May-15 16:23 zensols/cli/simple.py
+-rw-rw-r--  2.0 unx    15285 b- defN 22-May-15 16:23 zensols/cli/usage.py
+-rw-rw-r--  2.0 unx      996 b- defN 22-May-15 16:23 zensols/cli/util.py
+-rw-rw-r--  2.0 unx    16835 b- defN 22-May-15 16:23 zensols/cli/lib/config.py
+-rw-rw-r--  2.0 unx     5577 b- defN 22-May-15 16:23 zensols/cli/lib/log.py
+-rw-rw-r--  2.0 unx     3265 b- defN 22-May-15 16:23 zensols/cli/lib/package.py
+-rw-rw-r--  2.0 unx    11964 b- defN 22-May-15 16:23 zensols/cli/lib/support.py
+-rw-rw-r--  2.0 unx      690 b- defN 22-May-15 16:23 zensols/config/__init__.py
+-rw-rw-r--  2.0 unx    11815 b- defN 22-May-15 16:23 zensols/config/configbase.py
+-rw-rw-r--  2.0 unx     5633 b- defN 22-May-15 16:23 zensols/config/configfac.py
+-rw-rw-r--  2.0 unx    10733 b- defN 22-May-15 16:23 zensols/config/dictable.py
+-rw-rw-r--  2.0 unx     3120 b- defN 22-May-15 16:23 zensols/config/dictconfig.py
+-rw-rw-r--  2.0 unx     2071 b- defN 22-May-15 16:23 zensols/config/diff.py
+-rw-rw-r--  2.0 unx     4043 b- defN 22-May-15 16:23 zensols/config/envconfig.py
+-rw-rw-r--  2.0 unx    11398 b- defN 22-May-15 16:23 zensols/config/facbase.py
+-rw-rw-r--  2.0 unx    16443 b- defN 22-May-15 16:23 zensols/config/importfac.py
+-rw-rw-r--  2.0 unx    21081 b- defN 22-May-15 16:23 zensols/config/importini.py
+-rw-rw-r--  2.0 unx     4205 b- defN 22-May-15 16:23 zensols/config/importyaml.py
+-rw-rw-r--  2.0 unx    13128 b- defN 22-May-15 16:23 zensols/config/iniconfig.py
+-rw-rw-r--  2.0 unx     2737 b- defN 22-May-15 16:23 zensols/config/json.py
+-rw-rw-r--  2.0 unx     2760 b- defN 22-May-15 16:23 zensols/config/keychain.py
+-rw-rw-r--  2.0 unx     6857 b- defN 22-May-15 16:23 zensols/config/meta.py
+-rw-rw-r--  2.0 unx    11994 b- defN 22-May-15 16:23 zensols/config/serial.py
+-rw-rw-r--  2.0 unx     2996 b- defN 22-May-15 16:23 zensols/config/strconfig.py
+-rw-rw-r--  2.0 unx     7175 b- defN 22-May-15 16:23 zensols/config/writable.py
+-rw-rw-r--  2.0 unx     7171 b- defN 22-May-15 16:23 zensols/config/writeback.py
+-rw-rw-r--  2.0 unx     9858 b- defN 22-May-15 16:23 zensols/config/yaml.py
+-rw-rw-r--  2.0 unx      126 b- defN 22-May-15 16:23 zensols/introspect/__init__.py
+-rw-rw-r--  2.0 unx     6335 b- defN 22-May-15 16:23 zensols/introspect/imp.py
+-rw-rw-r--  2.0 unx    16097 b- defN 22-May-15 16:23 zensols/introspect/inspect.py
+-rw-rw-r--  2.0 unx      123 b- defN 22-May-15 16:23 zensols/multi/__init__.py
+-rw-rw-r--  2.0 unx    13300 b- defN 22-May-15 16:23 zensols/multi/stash.py
+-rw-rw-r--  2.0 unx      354 b- defN 22-May-15 16:23 zensols/persist/__init__.py
+-rw-rw-r--  2.0 unx    20174 b- defN 22-May-15 16:23 zensols/persist/annotation.py
+-rw-rw-r--  2.0 unx     9813 b- defN 22-May-15 16:23 zensols/persist/composite.py
+-rw-rw-r--  2.0 unx     8829 b- defN 22-May-15 16:23 zensols/persist/dealloc.py
+-rw-rw-r--  2.0 unx    19042 b- defN 22-May-15 16:23 zensols/persist/domain.py
+-rw-rw-r--  2.0 unx     5327 b- defN 22-May-15 16:23 zensols/persist/shelve.py
+-rw-rw-r--  2.0 unx    11521 b- defN 22-May-15 16:23 zensols/persist/stash.py
+-rw-rw-r--  2.0 unx      362 b- defN 22-May-15 16:23 zensols/util/__init__.py
+-rw-rw-r--  2.0 unx     3131 b- defN 22-May-15 16:23 zensols/util/executor.py
+-rw-rw-r--  2.0 unx     5479 b- defN 22-May-15 16:23 zensols/util/log.py
+-rw-rw-r--  2.0 unx     2934 b- defN 22-May-15 16:23 zensols/util/pkgres.py
+-rw-rw-r--  2.0 unx      916 b- defN 22-May-15 16:23 zensols/util/std.py
+-rw-rw-r--  2.0 unx     3343 b- defN 22-May-15 16:23 zensols/util/tempfile.py
+-rw-rw-r--  2.0 unx     5726 b- defN 22-May-15 16:23 zensols/util/time.py
+-rw-rw-r--  2.0 unx     7355 b- defN 22-May-15 16:23 zensols.util-1.9.0.dist-info/METADATA
+-rw-rw-r--  2.0 unx       92 b- defN 22-May-15 16:23 zensols.util-1.9.0.dist-info/WHEEL
+-rw-rw-r--  2.0 unx       89 b- defN 22-May-15 16:23 zensols.util-1.9.0.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     4637 b- defN 22-May-15 16:23 zensols.util-1.9.0.dist-info/RECORD
+57 files, 478973 bytes uncompressed, 135690 bytes compressed:  71.7%
```

## zipnote {}

```diff
@@ -57,15 +57,18 @@
 
 Filename: zensols/config/diff.py
 Comment: 
 
 Filename: zensols/config/envconfig.py
 Comment: 
 
-Filename: zensols/config/factory.py
+Filename: zensols/config/facbase.py
+Comment: 
+
+Filename: zensols/config/importfac.py
 Comment: 
 
 Filename: zensols/config/importini.py
 Comment: 
 
 Filename: zensols/config/importyaml.py
 Comment: 
@@ -150,20 +153,20 @@
 
 Filename: zensols/util/tempfile.py
 Comment: 
 
 Filename: zensols/util/time.py
 Comment: 
 
-Filename: zensols.util-1.8.0.dist-info/METADATA
+Filename: zensols.util-1.9.0.dist-info/METADATA
 Comment: 
 
-Filename: zensols.util-1.8.0.dist-info/WHEEL
+Filename: zensols.util-1.9.0.dist-info/WHEEL
 Comment: 
 
-Filename: zensols.util-1.8.0.dist-info/top_level.txt
+Filename: zensols.util-1.9.0.dist-info/top_level.txt
 Comment: 
 
-Filename: zensols.util-1.8.0.dist-info/RECORD
+Filename: zensols.util-1.9.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## zensols/config/__init__.py

```diff
@@ -15,15 +15,16 @@
 
 
 from .writable import *
 from .dictable import *
 from .serial import *
 from .configbase import *
 from .strconfig import *
-from .factory import *
+from .facbase import *
+from .importfac import *
 from .writeback import *
 from .yaml import *
 from .iniconfig import *
 from .dictconfig import *
 from .diff import *
 from .json import *
 from .configfac import *
```

## zensols/config/configbase.py

```diff
@@ -225,15 +225,18 @@
         last_ex = None
         if sections is None:
             sections = self.sections
         for sec in sections:
             if logger.isEnabledFor(logging.DEBUG):
                 logger.debug(f'copying section {sec}')
             try:
-                for k, v in self.get_options(sec).items():
+                opts: Dict[str, Any] = self.get_options(sec)
+                if opts is None:
+                    raise ConfigurableError(f"No such section: '{sec}'")
+                for k, v in opts.items():
                     to_populate.set_option(k, v, sec)
             # robust is needed by lib.ConfigurationImporter._load(); but deal
             # only with interpolation errors
             except ConfigurableError as e:
                 raise e
             except Exception as e:
                 if not robust:
```

## zensols/config/configfac.py

```diff
@@ -3,15 +3,14 @@
 """
 __author__ = 'Paul Landes'
 
 from typing import Dict, Any, Type
 from dataclasses import dataclass, field
 import sys
 import logging
-import re
 from pathlib import Path
 from zensols.introspect import ClassImporter
 from . import Configurable, IniConfig
 
 logger = logging.getLogger(__name__)
 
 
@@ -23,14 +22,19 @@
     This class often is used to create a factory from just a path, which then
     uses the extension with the :obj:`EXTENSION_TO_TYPE` mapping to select the
     class.  Top level/entry point configuration should use ``conf`` as the
     extension allowing the :class:`.ImportIni` to import other configuration.
     An example of this is the :class:`.ConfigurationImporter` loading user
     specific configuration.
 
+    If the class uses type type ``import``, the type is prepended with
+    ``import`` and then mapped using :obj:`EXTENSION_TO_TYPE`.  This allows
+    mixing of different files in one ``config_files`` entry and avoids multiple
+    import sections.
+
     :see: `.ImportIniConfig`
 
     """
     EXTENSION_TO_TYPE = {'conf': 'ini',
                          'ini': 'ini',
                          'yml': 'yaml',
                          'json': 'json'}
@@ -39,16 +43,16 @@
     """
     TYPE_NAME = 'type'
     """The section entry for the configurable type (eg ``ini`` vs ``yaml``)."""
 
     SINGLE_CONFIG_FILE = 'config_file'
     """The section entry for the configuration file."""
 
-    FILE_EXT_REGEX = re.compile(r'.+\.([a-zA-Z]+?)$')
-    """A regular expression to parse out the extension from a file name."""
+    CLASS_NAME = 'class_name'
+    """The section entry for the class to use."""
 
     kwargs: Dict[str, Any] = field(default_factory=dict)
     """The keyword arguments given to the factory on creation."""
 
     def _mod_name(self) -> str:
         """Return the ``config`` (parent) module name."""
         mname = sys.modules[__name__].__name__
@@ -89,19 +93,16 @@
         class_name = f'{mod_name}.{config_type}Config'
         return self.from_class_name(class_name)
 
     def _path_to_type(self, path: Path) -> str:
         """Map a path to a ``config type``.  See :meth:`from_type`.
 
         """
-        m = self.FILE_EXT_REGEX.match(path.name)
-        if m is not None:
-            ext = m.group(1)
-        else:
-            ext = None
+        ext = path.suffix
+        ext = None if len(ext) == 0 else ext[1:]
         if logger.isEnabledFor(logging.DEBUG):
             logger.debug(f"using extension to map: '{ext}'")
         class_type = self.EXTENSION_TO_TYPE.get(ext)
         if class_type is None:
             class_type = 'importini'
         return class_type
 
@@ -112,35 +113,40 @@
         """
         if path.is_dir():
             inst = IniConfig(path, **self.kwargs)
         else:
             class_type = self._path_to_type(path)
             old_kwargs = self.kwargs
             self.kwargs = dict(self.kwargs)
-            self.kwargs['config_file'] = path
+            self.kwargs[self.SINGLE_CONFIG_FILE] = path
             try:
                 inst = self.from_type(class_type)
             finally:
                 self.kwargs = old_kwargs
         return inst
 
     @classmethod
     def from_section(cls: Type, kwargs: Dict[str, Any], section: str) -> \
             Configurable:
         params = dict(kwargs)
-        class_name = params.get('class_name')
+        class_name = params.get(cls.CLASS_NAME)
         self = cls(params)
         tpe = params.get(self.TYPE_NAME)
         config_file = params.get(self.SINGLE_CONFIG_FILE)
         config: Configurable
         if class_name is not None:
-            del params['class_name']
+            del params[self.CLASS_NAME]
             config = self.from_class_name(class_name)
         elif tpe is not None:
             del params[self.TYPE_NAME]
+            if tpe == 'import' and config_file is not None:
+                ext = Path(config_file).suffix[1:]
+                etype = self.EXTENSION_TO_TYPE.get(ext)
+                if etype is not None:
+                    tpe = f'import{etype}'
             config = self.from_type(tpe)
         elif config_file is not None:
             del params[self.SINGLE_CONFIG_FILE]
             config = self.from_path(Path(config_file))
         else:
             self._raise(f"No loader information for '{section}': {params}")
         if logger.isEnabledFor(logging.INFO):
```

## zensols/config/diff.py

```diff
@@ -28,27 +28,29 @@
         self._change_format = change_format
         self._init = False
 
     def _diff(self) -> DictionaryConfig:
         try:
             from deepdiff import DeepDiff
         except ModuleNotFoundError as e:
-            m = 'DeepDiff module is not installed, use: pip install deepdiff'
+            m = "DeepDiff module is not installed, use: 'pip install deepdiff'"
             raise APIError(m) from e
         da = DictionaryConfig.from_config(self._config_a)
         db = DictionaryConfig.from_config(self._config_b)
         dd = DeepDiff(da.asdict(), db.asdict())
+        if 'values_changed' not in dd:
+            keys = ', '.join(dd.keys())
+            raise APIError(f'No values changed, found keys: {keys}')
         vc = dd['values_changed']
         changes = collections.defaultdict(dict)
         for sec_prop, vals in vc.items():
             m: re.Match = self._SEC_PROP_REGEX.match(sec_prop)
             if m is None:
                 raise ValueError(f'Unknown diff format: {sec_prop}')
             sec, prop = m.groups()
-            #cstr = f"{vals['old_value']} -> {vals['new_value']}"
             cstr = self._change_format.format(
                 vals['old_value'], vals['new_value'])
             changes[sec][prop] = cstr
         return DictionaryConfig(changes)
 
     def _get_config(self) -> Dict[str, Dict[str, str]]:
         if not self._init:
```

## zensols/config/importyaml.py

```diff
@@ -55,14 +55,16 @@
 
     def _post_config(self):
         def repl_node(par: Dict[str, Any]):
             repl = {}
             for k, c in par.items():
                 if isinstance(c, dict):
                     repl_node(c)
+                elif isinstance(c, list):
+                    repl[k] = tuple(c)
                 elif isinstance(c, str):
                     template = _Template(c)
                     rc = template.safe_substitute(context)
                     if logger.isEnabledFor(logging.DEBUG):
                         logger.debug(f'subs: {c} -> {rc}')
                     repl[k] = rc
             par.update(repl)
```

## zensols/config/serial.py

```diff
@@ -1,13 +1,15 @@
 """Simple string based serialization.
 
 """
 __author__ = 'Paul Landes'
 
-from typing import Dict, Union, Any, Set, Tuple, List, Iterable
+import typing
+from typing import Dict, Union, Any, Set, Tuple, List, Iterable, Type
+import dataclasses
 from dataclasses import dataclass, field
 import logging
 import json
 from json import JSONEncoder
 from itertools import chain
 import re
 import pkg_resources
```

## zensols/config/yaml.py

```diff
@@ -26,15 +26,17 @@
     """
     CLASS_VER = 0
 
     def __init__(self, config_file: Union[str, Path, TextIOBase] = None,
                  default_section: str = None, default_vars: str = None,
                  delimiter: str = '$', sections_name: str = 'sections',
                  sections: Set[str] = None):
-        """Initialize this instance.
+        """Initialize this instance.  When sections are not set, and the sections are
+        not given in configuration file at location :obj:`sections_name` the
+        root is made a singleton section.
 
         :param config_file: the configuration file path to read from; if the
                             type is an instance of :class:`io.TextIOBase`, then
                             read it as a file object
 
         :param default_section: used as the default section when non given on
                                 the get methds such as :meth:`get_option`;
@@ -146,15 +148,15 @@
     def get_tree(self, name: str) -> Dict[str, Any]:
         """Get the YAML tree for a node in the configuration.
 
         :param name: the doted notation indicating which node in the tree to
                      retrieve
 
         """
-        def find(n, path, name):
+        def find(n: Union[Dict, Any], path: str, name: str):
             if logger.isEnabledFor(logging.DEBUG):
                 logger.debug(f'search: n={n}, path={path}, name={name}')
             if path == name:
                 if logger.isEnabledFor(logging.DEBUG):
                     logger.debug(f'found: <{n}>')
                 return n
             elif isinstance(n, dict):
@@ -244,15 +246,18 @@
         """Return the sections by finding the :obj:`section_name` based from the
         :obj:`root`.
 
         """
         if not hasattr(self, '_sections'):
             sec_key = f'{self.root}.{self.sections_name}'
             if self.has_option(sec_key):
-                self._sections = frozenset(self.get_option_list(sec_key))
+                secs = self.get_tree(sec_key)
+                if isinstance(secs, str):
+                    secs = self.get_option_list(sec_key)
+                self._sections = frozenset(secs)
             else:
-                self._sections = frozenset()
+                self._sections = frozenset([self.root])
         return self._sections
 
     @sections.setter
     def sections(self, sections: Set[str]):
         self._sections = sections
```

## zensols/multi/stash.py

```diff
@@ -82,19 +82,19 @@
             dtype = 'None'
         return f'{self.name} ({self.chunk_id}): data: {dtype}'
 
 
 @dataclass
 class MultiProcessStash(PrimablePreemptiveStash, metaclass=ABCMeta):
     """A stash that forks processes to process data in a distributed fashion.  The
-    stash is typically created by a
-    :class:`zensols.config.factory.ImportConfigFactory` in the child process.
-    Work is chunked (grouped) and then sent to child processes.  In each, a new
-    instance of this same stash is created using :class:`.ImportConfigFactory`
-    and then an abstract method is called to dump the data.
+    stash is typically created by a :class:`.ImportConfigFactory` in the child
+    process.  Work is chunked (grouped) and then sent to child processes.  In
+    each, a new instance of this same stash is created using
+    :class:`.ImportConfigFactory` and then an abstract method is called to dump
+    the data.
 
     The :obj:`delegate` stash is used to manage the actual persistence of the
     data.
 
     This implemetation of :meth:`prime` is to fork processes to accomplish the
     work.
```

## zensols/persist/annotation.py

```diff
@@ -1,13 +1,13 @@
 """Contains general purpose persistence library classes.
 
 """
 __author__ = 'Paul Landes'
 
-from typing import Union, Any
+from typing import Union, Any, Dict
 import logging
 import sys
 import re
 from copy import copy
 import pickle
 import time as tm
 from pathlib import Path
@@ -302,18 +302,18 @@
 
         """
         for pw in self.persisted.values():
             pw.clear()
 
 
 class PersistableContainer(Deallocatable):
-    """Classes can extend this that want to persist :class:`.PersistableWork`
+    """Classes can extend this that want to persist :class:`.PersistedWork`
     instances, which otherwise are not persistable.
 
-    This class also manages the deallocation of all :class:`.PersistableWork`
+    This class also manages the deallocation of all :class:`.PersistedWork`
     attributes of the class, which might be another reason to use it even if
     there isn't a persistence use case.
 
     If the class level attribute ``_PERSITABLE_TRANSIENT_ATTRIBUTES`` is set,
     all attributes given in this set will be set to ``None`` when pickled.
 
     If the class level attribute ``_PERSITABLE_REMOVE_ATTRIBUTES`` is set, all
@@ -322,15 +322,15 @@
     If the class level attribute ``_PERSITABLE_PROPERTIES`` is set, all
     properties given will be accessed for force creation before pickling.
 
     If the class level attribute ``_PERSITABLE_METHODS`` is set, all method
     given will be accessed for force creation before pickling.
 
     """
-    def __getstate__(self):
+    def __getstate__(self) -> Dict[str, Any]:
         if logger.isEnabledFor(logging.DEBUG):
             logger.debug(f'get state for {self.__class__}')
         removes = set()
         tran_attribute_name = '_PERSITABLE_TRANSIENT_ATTRIBUTES'
         remove_attribute_name = '_PERSITABLE_REMOVE_ATTRIBUTES'
         prop_attribute_name = '_PERSITABLE_PROPERTIES'
         meth_attribute_name = '_PERSITABLE_METHODS'
@@ -367,15 +367,15 @@
             for k in remove_attribs:
                 del state[k]
         if logger.isEnabledFor(logging.DEBUG):
             logger.debug(f'state keys for {self.__class__}: ' +
                          f'{", ".join(state.keys())}')
         return state
 
-    def __setstate__(self, state):
+    def __setstate__(self, state: Dict[str, Any]):
         """Set the owner to containing instance and the worker function to the owner's
         function by name.
 
         """
         self.__dict__.update(state)
         for k, v in state.items():
             if logger.isEnabledFor(logging.DEBUG):
```

## zensols/persist/composite.py

```diff
@@ -1,18 +1,18 @@
 """Stash implementations.
 
 """
 __author__ = 'Paul Landes'
 
-import logging
 from typing import Any, Set, Tuple
-from functools import reduce
+import logging
 import collections
-import shutil
+from functools import reduce
 from pathlib import Path
+import shutil
 from . import PersistableError, DirectoryStash
 
 logger = logging.getLogger(__name__)
 
 
 class MissingDataKeys(PersistableError):
     def __init__(self, keys: Set[str]):
@@ -38,15 +38,15 @@
     for very large objects (i.e. matrix/tensor) data.
 
     For this reason, it is important to properly group your load keys so the
     most related data goes together.  This is because if only one key is from
     the data is needed, the entire composite item is loaded.
 
     *Note:* If order of the data is important, use an instance of
-     :class:`collections.OrderedDict` as the attribute data.
+    :class:`collections.OrderedDict` as the attribute data.
 
     """
     INSTANCE_DIRECTORY_NAME = 'inst'
     COMPOSITE_DIRECTORY_NAME = 'comp'
 
     def __init__(self, path: Path, groups: Tuple[Set[str]],
                  attribute_name: str, load_keys: Set[str] = None):
@@ -69,53 +69,64 @@
                           stashs in to the attribute ``dict`` instance; only
                           these keys will exist in the loaded data, or ``None``
                           for all keys; this can be set after the creation of
                           the instance as well
 
         """
         super().__init__(path)
-        stashes = {}
-        comp_path = self.path / self.COMPOSITE_DIRECTORY_NAME
-        self.top_level_dir = self.path
-        self.stash_by_group = {}
-        self.stash_by_attribute = stashes
-        self.path = self.path / self.INSTANCE_DIRECTORY_NAME
-        self.groups = groups
-        self.all_keys = reduce(lambda a, b: a | b, groups)
-        self.load_keys = load_keys
         self.attribute_name = attribute_name
-        comps: Set[str]
+        self.load_keys = load_keys
         if load_keys is not None and not isinstance(load_keys, set):
             raise PersistableError(
                 f'Expecting set but got {load_keys} {type(load_keys)}')
+        self._top_level_dir = self.path
+        self.path = self.path / self.INSTANCE_DIRECTORY_NAME
+        self.groups = groups
+
+    @property
+    def groups(self) -> Tuple[Set[str]]:
+        """The groups of the ``dict`` composite attribute, which are sets of keys, each
+        of which are persisted to their respective directory.
+
+        """
+        return self._groups
+
+    @groups.setter
+    def groups(self, groups: Tuple[Set[str]]):
+        """The groups of the ``dict`` composite attribute, which are sets of keys, each
+        of which are persisted to their respective directory.
+
+        """
+        if len(groups) == 0:
+            raise PersistableError('Must have at least one group set')
+        self._groups = tuple(map(frozenset, groups))
+        stashes = {}
+        comp_path: Path = self._top_level_dir / self.COMPOSITE_DIRECTORY_NAME
+        self._stash_by_group = {}
+        self._stash_by_attribute = stashes
+        self._all_keys = frozenset(reduce(lambda a, b: a | b, groups))
+        comps: Set[str]
         for group in groups:
             if not isinstance(group, set):
                 raise PersistableError(
                     f'Composition {group} is not type set: ({type(group)})')
             name = '-'.join(sorted(group))
             path = comp_path / name
             comp_stash = DirectoryStash(path)
             comp_stash.group = group
             comp_stash.group_name = name
             for k in group:
                 if k in stashes:
                     raise PersistableError(
                         f'Duplicate name \'{k}\' in {groups}')
                 stashes[k] = comp_stash
-                self.stash_by_group[name] = comp_stash
+                self._stash_by_group[name] = comp_stash
         if logger.isEnabledFor(logging.INFO):
             logger.info(f'creating composit hash with groups: {self.groups}')
 
-    def clear(self):
-        logger.info('DirectoryCompositeStash: clearing')
-        if self.top_level_dir.is_dir():
-            if logger.isEnabledFor(logging.INFO):
-                logger.info(f'deleting subtree: {self.top_level_dir}')
-            shutil.rmtree(self.top_level_dir)
-
     def _to_composite(self, data: dict) -> Tuple[str, Any, Tuple[str, Any]]:
         """Create the composite data used to by the composite stashes to persist.
 
         :param data: the data item stored as the attribute in ``inst`` to
                      persist
 
         :return: a tuple with the following:
@@ -125,23 +136,23 @@
                  * list of tuples each having (stash name, data dict)
 
         """
         data_group = collections.defaultdict(lambda: {})
         is_ordered = isinstance(data, collections.OrderedDict)
         context = tuple(data.keys()) if is_ordered else None
         if logger.isEnabledFor(logging.DEBUG):
-            logger.debug(f'keys: {data.keys()}, groups: {self.all_keys}')
-        missing_keys: Set[str] = self.all_keys - set(data.keys())
+            logger.debug(f'keys: {data.keys()}, groups: {self._all_keys}')
+        missing_keys: Set[str] = self._all_keys - set(data.keys())
         if len(missing_keys) > 0:
             raise MissingDataKeys(missing_keys)
         for k, v in data.items():
-            if k not in self.stash_by_attribute:
+            if k not in self._stash_by_attribute:
                 raise PersistableError(
                     f'Unmapping/grouped attribute: {k} in {self.groups}')
-            stash = self.stash_by_attribute[k]
+            stash = self._stash_by_attribute[k]
             data_group[stash.group_name][k] = v
         data_group = tuple(data_group.items())
         if logger.isEnabledFor(logging.DEBUG):
             logger.debug(f'create group {data_group}')
         return context, data_group
 
     def dump(self, name: str, inst: Any):
@@ -149,15 +160,15 @@
             logger.debug(f'dump {name}({self.attribute_name}) ' +
                          f'-> {inst.__class__}')
         org_attr_val = getattr(inst, self.attribute_name)
         context, composite = self._to_composite(org_attr_val)
         try:
             setattr(inst, self.attribute_name, None)
             for group_name, composite_inst in composite:
-                stash = self.stash_by_group[group_name]
+                stash = self._stash_by_group[group_name]
                 stash.dump(name, composite_inst)
                 if logger.isEnabledFor(logging.DEBUG):
                     logger.debug(f'dump composite {group_name}/{name}: ' +
                                  f'context={context}, inst={composite_inst}')
             super().dump(name, (inst, context))
         finally:
             setattr(inst, self.attribute_name, org_attr_val)
@@ -168,20 +179,20 @@
         :param name: the ID key of the data item used in the composite stashes
 
         :param context: the load context (see :meth:`_to_composite`)
 
         """
         attr_name = self.attribute_name
         comp_data = {}
-        attribs = set(self.stash_by_attribute.keys())
+        attribs = set(self._stash_by_attribute.keys())
         if self.load_keys is not None:
             attribs = attribs & self.load_keys
         if logger.isEnabledFor(logging.DEBUG):
             logger.debug(f'load attribs: {attribs}')
-        for stash in self.stash_by_group.values():
+        for stash in self._stash_by_group.values():
             if len(stash.group & attribs) > 0:
                 data = stash.load(name)
                 logger.debug(f'loaded: {data}')
                 if data is None:
                     raise PersistableError(
                         f'Missing composite data for id: {name}, ' +
                         f'stash: {stash.group}, path: {stash.path}, ' +
@@ -204,7 +215,14 @@
     def load(self, name: str) -> Any:
         inst, context = super().load(name)
         attr_val = self._from_composite(name, context)
         if logger.isEnabledFor(logging.DEBUG):
             logger.debug(f'loaded {name}({self.attribute_name})')
         setattr(inst, self.attribute_name, attr_val)
         return inst
+
+    def clear(self):
+        logger.info('DirectoryCompositeStash: clearing')
+        if self._top_level_dir.is_dir():
+            if logger.isEnabledFor(logging.INFO):
+                logger.info(f'deleting subtree: {self._top_level_dir}')
+            shutil.rmtree(self._top_level_dir)
```

## Comparing `zensols/config/factory.py` & `zensols/config/importfac.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,350 +1,59 @@
-from __future__ import annotations
-"""Classes that create new instances of classes from application configuration
-objects and files.
+"""A configuration factory that (re)imports based on class name.
 
 """
 __author__ = 'Paul Landes'
 
-from typing import Dict, Any, Union, Type, Optional, Tuple
-from abc import ABC, abstractmethod
-from enum import Enum
-import types
+import typing
+from typing import Tuple, Dict, Optional, Union, Any, Type, Iterable
+import dataclasses
 import logging
-import inspect
+import types
 import re
-import copy as cp
-from pathlib import Path
-from time import time
-from zensols.util import APIError
-from zensols.introspect import (
-    ClassImporter, ClassResolver, DictionaryClassResolver
-)
-from zensols.config import Configurable
+from frozendict import frozendict
+from zensols.introspect import ClassResolver
 from zensols.persist import persisted, PersistedWork, Deallocatable
+from . import Settings, FactoryError, ImportClassResolver, ConfigFactory
 
 logger = logging.getLogger(__name__)
 
 
-class FactoryError(APIError):
-    """Raised when an object can not be instantianted by a :class:`.ConfigFactory`.
-
-    """
-    def __init__(self, msg: str, factory: ConfigFactory = None):
-        if factory is not None:
-            config = factory.config
-            if config is not None and hasattr(config, 'config_file') and \
-               isinstance(config.config_file, (str, Path)):
-                cf = config.config_file
-                if isinstance(cf, Path):
-                    cf = cf.absolute()
-                msg += f', in file: {cf}'
-        super().__init__(msg)
-
-
 class RedefinedInjectionError(FactoryError):
     """Raised when any attempt to redefine or reuse injections for a class
     """
     pass
 
 
-class FactoryState(Enum):
-    """The state updated from an instance of :class:`.ConfigFactory`.  Currently
-    the only state is that an object has finished being created.
-
-    Future states might inlude when a :class:`.ImportConfigFactory` has created
-    all objects from a configuration shared session.
-
-    """
-    CREATED = 1
-
-
-class FactoryStateObserver(ABC):
-    """An interface that recieves notifications that the factory has created this
-    instance.  This is useful for classes such as :class:`.Writeback`.
-
-    :see: :class:`.Writeback`
-
-    """
-    @abstractmethod
-    def _notify_state(self, state: FactoryState):
-        pass
-
-
-class FactoryClassImporter(ClassImporter):
-    """Just like the super class, but if instances of type
-    :class:`.FactoryStateObserver` are notified with a
-    :class:`.FactoryState.CREATED`.
-
-    """
-    def _bless(self, inst: Any) -> Any:
-        if isinstance(inst, FactoryStateObserver):
-            inst._notify_state(FactoryState.CREATED)
-        return super()._bless(inst)
-
-
-class ImportClassResolver(ClassResolver):
-    """Resolve a class name from a list of registered class names without the
-    module part.  This is used with the ``register`` method on
-    :class:`.ConfigFactory`.
-
-    :see: :meth:`.ConfigFactory.register`
-
-    """
-    def __init__(self, reload: bool = False):
-        self.reload = reload
-
-    def create_class_importer(self, class_name: str):
-        return FactoryClassImporter(class_name, reload=self.reload)
-
-    def find_class(self, class_name: str):
-        class_importer = self.create_class_importer(class_name)
-        return class_importer.get_module_class()[1]
-
-
-class ConfigFactory(object):
-    """Creates new instances of classes and configures them given data in a
-    configuration :class:`.Configurable` instance.
-
-    """
-    NAME_ATTRIBUTE = 'name'
-    """The *name* of the parameter given to ``__init__``.  If a parameter of this
-    name is on the instance being created it will be set from the name of the
-    section.
-
-    """
-
-    CONFIG_ATTRIBUTE = 'config'
-    """The *configuration* of the parameter given to ``__init__``.  If a parameter
-    of this name is on the instance being created it will be set as the
-    instance of the configuration given to the initializer of this factory
-    instance.
-
-    """
-
-    CONFIG_FACTORY_ATTRIBUTE = 'config_factory'
-    """The *configuration factory* of the parameter given to ``__init__``.  If a
-    parameter of this name is on the instance being created it will be set as
-    the instance of this configuration factory.
-
-    """
-
-    CLASS_NAME = 'class_name'
-    """The class name attribute in the section that identifies the fully qualified
-    instance to create.
-
-    """
-    def __init__(self, config: Configurable, pattern: str = '{name}',
-                 default_name: str = 'default',
-                 class_resolver: ClassResolver = None):
-        """Initialize a new factory instance.
-
-        :param config: the configuration used to create the instance; all data
-                       from the corresponding section is given to the
-                       ``__init__`` method
-        :param pattern: section pattern used to find the values given to the
-                        ``__init__`` method
-        :param config_param_name: the ``__init__`` parameter name used for the
-                                  configuration object given to the factory's
-                                  ``instance`` method; defaults to ``config``
-        :param config_param_name: the ``__init__`` parameter name used for the
-                                  instance name given to the factory's
-                                  ``instance`` method; defaults to ``name``
-
-        """
-        self.config = config
-        self.pattern = pattern
-        self.default_name = default_name
-        if class_resolver is None:
-            self.class_resolver = DictionaryClassResolver(
-                self.INSTANCE_CLASSES)
-        else:
-            self.class_resolver = class_resolver
-
-    @classmethod
-    def register(cls, instance_class: Type, name: str = None):
-        """Register a class with the factory.  This method assumes the factory instance
-        was created with a (default) :class:`.DictionaryClassResolver`.
-
-        :param instance_class: the class to register with the factory (not a
-                               string)
-
-        :param name: the name to use as the key for instance class lookups;
-                     defaults to the name of the class
-
-        """
-        if name is None:
-            name = instance_class.__name__
-        if logger.isEnabledFor(logging.DEBUG):
-            logger.debug(f'registering: {instance_class} for {cls} -> {name}')
-        cls.INSTANCE_CLASSES[name] = instance_class
-
-    def _find_class(self, class_name: str) -> Type:
-        """Resolve the class from the name."""
-        return self.class_resolver.find_class(class_name)
-
-    def _class_name_params(self, name: str):
-        """Get the class name and parameters to use for ``__init__``."""
-        sec = self.pattern.format(**{'name': name})
-        if logger.isEnabledFor(logging.DEBUG):
-            logger.debug(f'section: {sec}')
-        params = {}
-        try:
-            params.update(self.config.populate({}, section=sec))
-        except Exception as e:
-            raise FactoryError(
-                f'Can not populate from section {sec}', self) from e
-        class_name = params.get(self.CLASS_NAME)
-        if class_name is None:
-            if len(params) == 0:
-                raise FactoryError(f"No such entry: '{name}'", self)
-            else:
-                class_name = 'zensols.config.Settings'
-        else:
-            del params[self.CLASS_NAME]
-        return class_name, params
-
-    def _has_init_parameter(self, cls: Type, param_name: str):
-        args = inspect.signature(cls.__init__)
-        return param_name in args.parameters
-
-    def _instance(self, cls_desc: str, cls: Type, *args, **kwargs):
-        """Return the instance.
-
-        :param cls_desc: a description of the class (i.e. section name)
-
-        :param cls: the class to create the instance from
-
-        :param args: given to the ``__init__`` method
-
-        :param kwargs: given to the ``__init__`` method
-
-        """
-        if logger.isEnabledFor(logging.DEBUG):
-            logger.debug(f'args: {args}, kwargs: {kwargs}')
-        try:
-            if logger.isEnabledFor(logging.DEBUG):
-                logger.debug(f'config factory creating instance of {cls}')
-            inst = cls(*args, **kwargs)
-            if isinstance(inst, FactoryStateObserver):
-                inst._notify_state(FactoryState.CREATED)
-        except Exception as e:
-            raise FactoryError(f'Can not create \'{cls_desc}\' for class ' +
-                               f'{cls}({args})({kwargs}): {e}', self) from e
-        if logger.isEnabledFor(logging.DEBUG):
-            logger.debug(f'inst: {inst.__class__}')
-        return inst
-
-    def instance(self, name: Optional[str] = None, *args, **kwargs):
-        """Create a new instance using key ``name``.
-
-        :param name: the name of the class (by default) or the key name of the
-                     class used to find the class; this is the section name for
-                     the :class:`.ImportConfigFactory`
-
-        :param args: given to the ``__init__`` method
-
-        :param kwargs: given to the ``__init__`` method
-
-        """
-        if logger.isEnabledFor(logging.DEBUG):
-            logger.debug(f'new instance of {name}')
-        t0 = time()
-        name = self.default_name if name is None else name
-        if logger.isEnabledFor(logging.DEBUG):
-            logger.debug(f'creating instance of {name}')
-        class_name, params = self._class_name_params(name)
-        if self.CLASS_NAME in kwargs:
-            class_name = kwargs.pop(self.CLASS_NAME)
-        cls = self._find_class(class_name)
-        params.update(kwargs)
-        if self._has_init_parameter(cls, self.CONFIG_ATTRIBUTE) \
-           and self.CONFIG_ATTRIBUTE not in params:
-            logger.debug('setting config parameter')
-            params['config'] = self.config
-        if self._has_init_parameter(cls, self.NAME_ATTRIBUTE) \
-           and self.NAME_ATTRIBUTE not in params:
-            logger.debug('setting name parameter')
-            params['name'] = name
-        if self._has_init_parameter(cls, self.CONFIG_FACTORY_ATTRIBUTE) \
-           and self.CONFIG_FACTORY_ATTRIBUTE not in params:
-            logger.debug('setting config factory parameter')
-            params['config_factory'] = self
-        if logger.isEnabledFor(logging.DEBUG):
-            for k, v in params.items():
-                logger.debug(f'populating {k} -> {v} ({type(v)})')
-        inst = self._instance(name, cls, *args, **params)
-        if logger.isEnabledFor(logging.DEBUG):
-            logger.debug(f'created {name} instance of {cls.__name__} ' +
-                         f'in {(time() - t0):.2f}s')
-        return inst
-
-    def get_class(self, name: str) -> Type:
-        """Return a class by name.
-
-        :param name: the name of the class (by default) or the key name of the
-                     class used to find the class; this is the section name for
-                     the :class:`.ImportConfigFactory`
-        """
-        if logger.isEnabledFor(logging.DEBUG):
-            logger.debug(f'new instance of {name}')
-        name = self.default_name if name is None else name
-        if logger.isEnabledFor(logging.DEBUG):
-            logger.debug(f'creating instance of {name}')
-        class_name, params = self._class_name_params(name)
-        return self._find_class(class_name)
-
-    def from_config_string(self, v: str) -> Any:
-        """Create an instance from a string used as option values in the configuration.
-
-        """
-        try:
-            v = eval(v)
-        except Exception:
-            pass
-        return self.instance(v)
-
-    def clone(self) -> Any:
-        """Return a copy of this configuration factory that functionally works the
-        same.
-
-        """
-        return cp.copy(self)
-
-    def __call__(self, *args, **kwargs):
-        """Calls ``instance``.
-
-        """
-        return self.instance(*args, **kwargs)
-
-
 class ImportConfigFactory(ConfigFactory, Deallocatable):
     """Import a class by the fully qualified class name (includes the module).
 
     This is a convenience class for setting the parent class ``class_resolver``
     parameter.
 
     """
     _INSTANCE_REGEXP = re.compile(r'^instance(?:\((.+)\))?:\s*(.+)$',
                                   re.DOTALL)
     """The ``instance`` regular expression used to identify children attributes to
     set on the object.  The process if creation can chain from parent to
     children recursively.
 
     """
-
     _OBJECT_REGEXP = re.compile(r'^object(?:\((.+)\))?:\s*(.+)$',
                                 re.DOTALL)
     """The ``object`` regular expression used to instantiate non-shared singleton
     instances tied to the outside instance..
 
     """
-
+    _DATACLASS_REGEXP = re.compile(r'^dataclass\((.+)\):\s*(.+)$',
+                                   re.DOTALL)
+    """
+    """
     _INJECTS = {}
     """Track injections to fail on any attempts to redefine."""
+    _EMPTY_CHILD_PARAMS = frozendict()
 
     def __init__(self, *args, reload: Optional[bool] = False,
                  shared: Optional[bool] = True,
                  reload_pattern: Optional[Union[re.Pattern, str]] = None,
                  **kwargs):
         """Initialize the configuration factory.
 
@@ -528,49 +237,80 @@
 
     def _populate_instances(self, pconfig: str, section: str):
         child_params, inst_conf = self._parse_child_params(pconfig)
         return self._create_instance(section, inst_conf, child_params)
 
     def _object_instance(self, pconfig: str, class_name: str):
         params, inst_conf = self._parse_child_params(pconfig)
-        cls = self._find_class(class_name)
+        cls: Type = self._find_class(class_name)
         desc = f'object instance {class_name}'
         return super()._instance(desc, cls, **params)
 
+    def _dataclass_from_dict(self, cls: Type, data: Any):
+        if isinstance(data, str):
+            data = self.from_config_string(data)
+        if dataclasses.is_dataclass(cls) and isinstance(data, dict):
+            fieldtypes = {f.name: f.type for f in dataclasses.fields(cls)}
+            try:
+                param = {f: self._dataclass_from_dict(fieldtypes[f], data[f])
+                         for f in data}
+            except KeyError as e:
+                raise FactoryError(f"No datacalass field {e} in '{cls}, data: {data}'")
+            data = cls(**param)
+        elif isinstance(data, (tuple, list)):
+            origin: Type = typing.get_origin(cls)
+            cls = typing.get_args(cls)
+            if isinstance(cls, (tuple, list, set)) and len(cls) == 1:
+                cls = next(iter(cls))
+            data: Iterable[Any] = map(
+                lambda x: self._dataclass_from_dict(cls, x), data)
+            data = origin(data)
+        return data
+
+    def _dataclass_instance(self, class_name: str, section: str):
+        from_dict = self._dataclass_from_dict
+        cls: Type = self._find_class(class_name)
+        params = self._EMPTY_CHILD_PARAMS
+        inst: Settings = self._create_instance(section, params, params)
+        if isinstance(inst, (tuple, list)):
+            elems = map(lambda x: from_dict(cls, x.asdict()), inst)
+            inst = inst.__class__(elems)
+        else:
+            inst = from_dict(cls, inst.asdict())
+        return inst
+
     def from_config_string(self, v: str) -> Any:
         """Create an instance from a string that looks like :obj:`_INSTANCE_REGEXP` or
         :obj:`_OBJECT_REGEXP` used as option values in the configuration.
 
         """
         m = self._INSTANCE_REGEXP.match(v)
         if m is not None:
             pconfig, section = m.groups()
             v = self._populate_instances(pconfig, section)
         else:
             m = self._OBJECT_REGEXP.match(v)
             if m is not None:
-                v = self._object_instance(pconfig, section)
+                pconfig, class_name = m.groups()
+                v = self._object_instance(pconfig, class_name)
+            else:
+                m = self._DATACLASS_REGEXP.match(v)
+                if m is not None:
+                    class_name, section = m.groups()
+                    v = self._dataclass_instance(class_name, section)
         return v
 
     def _class_name_params(self, name):
         class_name, params = super()._class_name_params(name)
         insts = {}
         initial_reload = self.reload
         try:
             for k, v in params.items():
                 if isinstance(v, str):
-                    m = self._INSTANCE_REGEXP.match(v)
-                    if m is not None:
-                        pconfig, section = m.groups()
-                        insts[k] = self._populate_instances(pconfig, section)
-                    else:
-                        m = self._OBJECT_REGEXP.match(v)
-                        if m:
-                            pconfig, section = m.groups()
-                            insts[k] = self._object_instance(pconfig, section)
+                    insts[k] = self.from_config_string(v)
         finally:
             self._set_reload(initial_reload)
         params.update(insts)
         return class_name, params
 
     def _process_injects(self, sec_name, kwargs):
         pname = 'injects'
```

## Comparing `zensols.util-1.8.0.dist-info/METADATA` & `zensols.util-1.9.0.dist-info/METADATA`

 * *Files 7% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 Metadata-Version: 2.1
 Name: zensols.util
-Version: 1.8.0
+Version: 1.9.0
 Summary: Command line, configuration and persistence utilites generally used for any more than basic application.
 Home-page: https://github.com/plandes/util
 Author: Paul Landes
 Author-email: landes@mailc.net
 License: UNKNOWN
-Download-URL: https://github.com/plandes/util/releases/download/v1.8.0/zensols.util-1.8.0-py3-none-any.whl
+Download-URL: https://github.com/plandes/util/releases/download/v1.9.0/zensols.util-1.9.0-py3-none-any.whl
 Keywords: tooling
 Platform: UNKNOWN
 Description-Content-Type: text/markdown
 Requires-Dist: configparser (==3.5.0)
 Requires-Dist: PyYAML (>=5.4)
 Requires-Dist: parse (>=1.9.0)
 Requires-Dist: tqdm (==4.48.2)
@@ -74,69 +74,68 @@
 This library contains a full persistence layer and other utilities.  However, a
 quick and dirty example that uses the configuration and command line
 functionality is given below.  See the other [examples] to learn how else to
 use it.
 
 ```python
 from dataclasses import dataclass
+from enum import Enum, auto
 import os
 from io import StringIO
-from zensols.cli import ApplicationFactory, CliHarness
+from zensols.cli import CliHarness
 
 CONFIG = """
+# configure the command line
 [cli]
-class_name = zensols.cli.ActionCliManager
 apps = list: app
 
+# define the application, whose code is given below
 [app]
 class_name = fsinfo.Application
 """
 
+class Format(Enum):
+    short = auto()
+    long = auto()
+
 @dataclass
 class Application(object):
     """Toy application example that provides file system information.
 
     """
-    def ls(self, format: str = 'short'):
+    def ls(self, format: Format = Format.short):
         """List the contents of the directory.
 
-        :param format: the output format <short|long>
+        :param format: the output format
 
         """
         cmd = ['ls']
-        if format == 'long':
+        if format == Format.long:
             cmd.append('-l')
         os.system(' '.join(cmd))
 
 
-class FsInfoApplicationFactory(ApplicationFactory):
-    def __init__(self, *args, **kwargs):
-        kwargs.update(dict(package_resource='fsinfo',
-                           app_config_resource=StringIO(CONFIG)))
-        super().__init__(*args, **kwargs)
-
-
-if __name__ == '__main__':
-    harness = CliHarness(app_factory_class=FsInfoApplicationFactory)
-    harness.run().result
+if (__name__ == '__main__'):
+    harnes = CliHarness(app_config_resource=StringIO(CONFIG))
+    harnes.run()
 ```
 
 The framework automatically links each command line action mnemonic (i.e. `ls`)
 to the data class `Application` method `ls` and command line help.  For
 example:
 ```shell
 $ python ./fsinfo.py -h
 Usage: fsinfo.py [options]:
 
 List the contents of the directory.
 
 Options:
-  -h, --help                    show this help message and exit
-  --version                     show the program version and exit
-  -f, --format STRING   short   the output format <short|long>
+  -h, --help                        show this help message and exit
+  --version                         show the program version and exit
+  -f, --format <long|short>  short  the output format
 
 $ python ./fsinfo.py -f short
 __pycache__  fsinfo.py
 ```
 
 See the [full example] that demonstrates more complex command line handling,
 documentation and explanation.
```

## Comparing `zensols.util-1.8.0.dist-info/RECORD` & `zensols.util-1.9.0.dist-info/RECORD`

 * *Files 8% similar despite different names*

```diff
@@ -8,49 +8,50 @@
 zensols/cli/simple.py,sha256=NgYm0jSASo-_cF3I1I88IXQ1yu_SvP9wF8j6pwEOYdA,9544
 zensols/cli/usage.py,sha256=RA6QcIYYumijgmgGSbzmMqZdBlUX2UARDA2hDPrtiyc,15285
 zensols/cli/util.py,sha256=_CwEH-SbM_uDc2AuexZNHS3xNZ9Xx5pFIzS8_cuhBgs,996
 zensols/cli/lib/config.py,sha256=DGgCm9DptZDHcvmt3j3AMLWKWYn9HGuVQ8dj0aDFDxM,16835
 zensols/cli/lib/log.py,sha256=K6kucsMYpHd_SWKbjiiXMgkrmOIG2CTW_Z55jIzMz6w,5577
 zensols/cli/lib/package.py,sha256=TdifLcST1i4RXe2DdbpGMLhjgQrdrtcD8kpvPVrI8Dk,3265
 zensols/cli/lib/support.py,sha256=9XFm0fft4aIxFP9e0ppnyWpWTHzDzRfOkTORqoXv6gM,11964
-zensols/config/__init__.py,sha256=E4W1UZ5L9nLmiL5KItWcNZ7NZ-Zf9XH0de9q447G7Gw,665
-zensols/config/configbase.py,sha256=ud0jRbmWwlkZ31UaDU-SiHq4rbV9U4lsAXiouQ8rKUg,11665
-zensols/config/configfac.py,sha256=iEit7GJ7vZ-NTxTbUEAflL2kQXKhISSLatzqYN2eGdg,5247
+zensols/config/__init__.py,sha256=q_PwrvTH9Iy4hqGt4t6hZNAuxKydpsc-rx8yatcWxeQ,690
+zensols/config/configbase.py,sha256=N59RzH21NLtcLaYiZEak0z9T_Okc8sr-vxdlZYRNgH8,11815
+zensols/config/configfac.py,sha256=VGRZHzmPQpBguufNkH2v6k1FLuVZK2S_1zZpoeeoYPs,5633
 zensols/config/dictable.py,sha256=ofYwOJk9vnwSblqMzOjheXnJjNsiF4vuL8pOXQtNDEE,10733
 zensols/config/dictconfig.py,sha256=2b9uRJG5Dal_83pQ2Qu2sr2pEbJnqHB2iWWruJFctuc,3120
-zensols/config/diff.py,sha256=0grf6NY1G-mvVp3DCdBl4yrblnbzmlLB_wkDxt-6Ziw,1987
+zensols/config/diff.py,sha256=BepdapuWhoJ8gmCt1kF-9dovJc4gxSkuNMgkqjqe554,2071
 zensols/config/envconfig.py,sha256=23N2MKLuan00_RLUO8n3DoJVJhtzOxnVH61oXGPPdHY,4043
-zensols/config/factory.py,sha256=GAOgS2MfUV6OkreNGMNfCDIWsHgcBoew2j54C-dJFwo,25934
+zensols/config/facbase.py,sha256=eR8JCuiL1Rw_M9CG7Txn0gY6SLK8OsYHoQ7uJmnkGqA,11398
+zensols/config/importfac.py,sha256=XOrXdfuG2LJKHsA28uozcg9i9Xi-301qzwSA87lxKfc,16443
 zensols/config/importini.py,sha256=pxatPL5TS4HfkQjXcNJfVquZUjTPIZRKjK0J0R8uKqc,21081
-zensols/config/importyaml.py,sha256=oRxnvqX0r0w6trbxHBvYV7qMnqvv3ab_dkkZReAYeHQ,4124
+zensols/config/importyaml.py,sha256=qUdNCoDL8bcc6aEmPQF0OoFTokRMCD_UlAytqnBtCGQ,4205
 zensols/config/iniconfig.py,sha256=aX93Spqfvtgc9dZObZGuOvp8CM7zhY7bFCtYT7O1Qjw,13128
 zensols/config/json.py,sha256=7vP5Wl0L76_SGE0fICTqn2OuWQSycf7zQdOnWRPhNXs,2737
 zensols/config/keychain.py,sha256=D_hg80Euj2Gu97g4R8XI6_4r4vLnjTXqWaJ6b2kK6Vw,2760
 zensols/config/meta.py,sha256=M_pquDrj7Jh7B6UltuNmUgrQjlM9IyDQIHITsE8XYCQ,6857
-zensols/config/serial.py,sha256=lwp7bSFe0fV5iDuzvZHrTpsw7Vey5gm-MtbUG8QrLQE,11955
+zensols/config/serial.py,sha256=ooxxX9kqUz-B4dLP-ScRATDA-wfFV8tZr0JNuhiNYh4,11994
 zensols/config/strconfig.py,sha256=R4IlnaOjR8rbP-wamkxLu00OQzItySFE16LE-NrWOAs,2996
 zensols/config/writable.py,sha256=dA-XO4wb7qs8230D4KUZ2kTHZb9TQ9z0iWpMTphQfn0,7175
 zensols/config/writeback.py,sha256=ylklLeDdJ8_3YVzq9E9AnEcBKW3TogVlOgvLX6d8sAw,7171
-zensols/config/yaml.py,sha256=g13v_cCThWtimzkUKO5xxt3CRCH77fko0BIqulegj48,9531
+zensols/config/yaml.py,sha256=Tm8iV70nwu2EnjK4IBiyGoxzoSDLoLDcag2jSmNMPbI,9858
 zensols/introspect/__init__.py,sha256=5nzF0zZGUyw7-0R5wfJZ7_TvbXjAqT3tTrrOwnxlyrQ,126
 zensols/introspect/imp.py,sha256=5zTfYpYhoWesbqDsdg1L8WtnnP9q-p-fV50A1Si2ESc,6335
 zensols/introspect/inspect.py,sha256=pu7ZR0w4o2fwuQxsAyH9rHVD6GypnSzKKydxM2vQv_4,16097
 zensols/multi/__init__.py,sha256=g1c6GLjBN0-2jxshUaPth47pt8unmy33ai5FLoZtewA,123
-zensols/multi/stash.py,sha256=rvY22JtzKFJRAvhgugIOTFP1Rm-30Gdh90NvEF_GFj0,13321
+zensols/multi/stash.py,sha256=H58ytNLHs6wvoi9gujPQMV03W9HumVoGrILgR0N4G8o,13300
 zensols/persist/__init__.py,sha256=5DEXBhGff4ZHnffzqqB2XWfUyx6mMFQDS3yaQBY8XL8,354
-zensols/persist/annotation.py,sha256=qNj7-GlV1rpQlhP1htSTHaRoKWA0q_mNw_kg9_c3R50,20138
-zensols/persist/composite.py,sha256=39arQDyFybIwoBQI5GQqfGxBPSM8vR-Q1mIPLDBU-HQ,9142
+zensols/persist/annotation.py,sha256=POUWt9vOqqttmz2YN3ydGPHClbIcg5e8Yept-Enro7g,20174
+zensols/persist/composite.py,sha256=DMwZIvo1AEqm-GD7gNIQ8O1ojoC6nPrMZdhGkKdVMBM,9813
 zensols/persist/dealloc.py,sha256=IdnvuGgGexo0qlE-WiTHBAvjQVK7yE-FcAMxljW7wXs,8829
 zensols/persist/domain.py,sha256=sOju6b9_pNx5fY0HEtBMKWlvMv4BpH5zmNHDZApV2B8,19042
 zensols/persist/shelve.py,sha256=GrNRbO5zWXlIyJkzneA7d7jl-zX0CkEDJfxE9dlEN-o,5327
 zensols/persist/stash.py,sha256=BvBIxHnbVvnUhCf2YQCiYR1TFzqK9zT7nmiBwrXeW-k,11521
 zensols/util/__init__.py,sha256=bbF62-SMrlyoRrEG4S3C2LZZQUfveIFFWKdh50ouOu0,362
 zensols/util/executor.py,sha256=Mq0fdJujf5SirIWH5DsOpktmKxSNzG5vIZBWtUt6Ue8,3131
 zensols/util/log.py,sha256=NUZnglcGlEENLLlEhN6rIDkJagkGatKKdbAh0EU4ps4,5479
 zensols/util/pkgres.py,sha256=TlvzdkqykgoKPUdAbhYsps6B7x0QB0VKGKTzEjsd-x8,2934
 zensols/util/std.py,sha256=6QoN-vI2oh30SgBSTKOPKqkTun51WW0nhSqpoozWmV4,916
 zensols/util/tempfile.py,sha256=ufKwYRa1pglsN4x9_dyHvtonlp0CJDVIUDTwnklqNdI,3343
 zensols/util/time.py,sha256=oKLV6TJtS-0PrjOvPYuz62dMP7FD6JFn_nJDTlhib2k,5726
-zensols.util-1.8.0.dist-info/METADATA,sha256=17VgOc2cqwforliWVLFkMUyuuQOrErbigs4HG-DvbMg,7521
-zensols.util-1.8.0.dist-info/WHEEL,sha256=ewwEueio1C2XeHTvT17n8dZUJgOvyCWCt0WVNLClP9o,92
-zensols.util-1.8.0.dist-info/top_level.txt,sha256=ZGuw8Dsm-nWbw_rKweUaOBUJLVh0Y5UlOxYGBOQvUqw,89
-zensols.util-1.8.0.dist-info/RECORD,,
+zensols.util-1.9.0.dist-info/METADATA,sha256=TTinEUqzfG3rHL3EEiIXmotrIXLYaF1jt7mdEJraWZ4,7355
+zensols.util-1.9.0.dist-info/WHEEL,sha256=ewwEueio1C2XeHTvT17n8dZUJgOvyCWCt0WVNLClP9o,92
+zensols.util-1.9.0.dist-info/top_level.txt,sha256=ZGuw8Dsm-nWbw_rKweUaOBUJLVh0Y5UlOxYGBOQvUqw,89
+zensols.util-1.9.0.dist-info/RECORD,,
```

