# Comparing `tmp/zensols.mimic-1.7.0-py3-none-any.whl.zip` & `tmp/zensols.mimic-1.7.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,38 +1,38 @@
-Zip file size: 49013 bytes, number of entries: 36
--rw-rw-r--  2.0 unx      169 b- defN 24-Apr-14 20:20 zensols/mimic/__init__.py
--rw-rw-r--  2.0 unx    21058 b- defN 24-Apr-14 20:20 zensols/mimic/adm.py
--rw-rw-r--  2.0 unx     8433 b- defN 24-Apr-14 20:20 zensols/mimic/app.py
--rw-rw-r--  2.0 unx      828 b- defN 24-Apr-14 20:20 zensols/mimic/cli.py
--rw-rw-r--  2.0 unx     5471 b- defN 24-Apr-14 20:20 zensols/mimic/corpus.py
--rw-rw-r--  2.0 unx    15020 b- defN 24-Apr-14 20:20 zensols/mimic/domain.py
--rw-rw-r--  2.0 unx    29399 b- defN 24-Apr-14 20:20 zensols/mimic/note.py
--rw-rw-r--  2.0 unx     5698 b- defN 24-Apr-14 20:20 zensols/mimic/parafac.py
--rw-rw-r--  2.0 unx    11151 b- defN 24-Apr-14 20:20 zensols/mimic/persist.py
--rw-rw-r--  2.0 unx     4837 b- defN 24-Apr-14 20:20 zensols/mimic/regexnote.py
--rw-rw-r--  2.0 unx     5808 b- defN 24-Apr-14 20:20 zensols/mimic/tokenizer.py
--rw-r--r--  2.0 unx     2106 b- defN 24-Apr-14 20:20 zensols/mimic/resources/app.conf
--rw-rw-r--  2.0 unx     2995 b- defN 24-Apr-14 20:20 zensols/mimic/resources/decorator.conf
--rw-rw-r--  2.0 unx     1673 b- defN 24-Apr-14 20:20 zensols/mimic/resources/default.conf
--rw-rw-r--  2.0 unx      368 b- defN 24-Apr-14 20:20 zensols/mimic/resources/obj.conf
--rw-r--r--  2.0 unx      230 b- defN 24-Apr-14 20:20 zensols/mimic/resources/postgres.conf
--rw-r--r--  2.0 unx     2569 b- defN 24-Apr-14 20:20 zensols/mimic/resources/conf/corpus.conf
--rw-rw-r--  2.0 unx     1278 b- defN 24-Apr-14 20:20 zensols/mimic/resources/conf/lang.conf
--rw-rw-r--  2.0 unx     2170 b- defN 24-Apr-14 20:20 zensols/mimic/resources/conf/note.conf
--rw-rw-r--  2.0 unx     2662 b- defN 24-Apr-14 20:20 zensols/mimic/resources/conf/persist.conf
--rw-rw-r--  2.0 unx      850 b- defN 24-Apr-14 20:20 zensols/mimic/resources/conf/remove-space.conf
--rw-rw-r--  2.0 unx     1628 b- defN 24-Apr-14 20:20 zensols/mimic/resources/postgres/admission.sql
--rw-rw-r--  2.0 unx     1218 b- defN 24-Apr-14 20:20 zensols/mimic/resources/postgres/icd.sql
--rw-rw-r--  2.0 unx      161 b- defN 24-Apr-14 20:20 zensols/mimic/resources/postgres/medications.sql
--rw-r--r--  2.0 unx     2226 b- defN 24-Apr-14 20:20 zensols/mimic/resources/postgres/note.sql
--rw-rw-r--  2.0 unx      320 b- defN 24-Apr-14 20:20 zensols/mimic/resources/postgres/patient.sql
--rw-rw-r--  2.0 unx     1621 b- defN 24-Apr-14 20:20 zensols/mimic/resources/sqlite/admission.sql
--rw-r--r--  2.0 unx     1216 b- defN 24-Apr-14 20:20 zensols/mimic/resources/sqlite/icd.sql
--rw-r--r--  2.0 unx      160 b- defN 24-Apr-14 20:20 zensols/mimic/resources/sqlite/medications.sql
--rw-r--r--  2.0 unx     2214 b- defN 24-Apr-14 20:20 zensols/mimic/resources/sqlite/note.sql
--rw-rw-r--  2.0 unx      318 b- defN 24-Apr-14 20:20 zensols/mimic/resources/sqlite/patient.sql
--rw-rw-r--  2.0 unx     7790 b- defN 24-Apr-14 20:20 zensols.mimic-1.7.0.dist-info/METADATA
--rw-rw-r--  2.0 unx       92 b- defN 24-Apr-14 20:20 zensols.mimic-1.7.0.dist-info/WHEEL
--rw-rw-r--  2.0 unx       45 b- defN 24-Apr-14 20:20 zensols.mimic-1.7.0.dist-info/entry_points.txt
--rw-rw-r--  2.0 unx       14 b- defN 24-Apr-14 20:20 zensols.mimic-1.7.0.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     3243 b- defN 24-Apr-14 20:20 zensols.mimic-1.7.0.dist-info/RECORD
-36 files, 147039 bytes uncompressed, 43743 bytes compressed:  70.3%
+Zip file size: 49568 bytes, number of entries: 36
+-rw-rw-r--  2.0 unx      169 b- defN 24-May-11 14:22 zensols/mimic/__init__.py
+-rw-rw-r--  2.0 unx    21127 b- defN 24-May-11 14:22 zensols/mimic/adm.py
+-rw-rw-r--  2.0 unx     8433 b- defN 24-May-11 14:22 zensols/mimic/app.py
+-rw-rw-r--  2.0 unx      828 b- defN 24-May-11 14:22 zensols/mimic/cli.py
+-rw-rw-r--  2.0 unx     5471 b- defN 24-May-11 14:22 zensols/mimic/corpus.py
+-rw-rw-r--  2.0 unx    15020 b- defN 24-May-11 14:22 zensols/mimic/domain.py
+-rw-rw-r--  2.0 unx    30524 b- defN 24-May-11 14:22 zensols/mimic/note.py
+-rw-rw-r--  2.0 unx     5698 b- defN 24-May-11 14:22 zensols/mimic/parafac.py
+-rw-rw-r--  2.0 unx    12443 b- defN 24-May-11 14:22 zensols/mimic/persist.py
+-rw-rw-r--  2.0 unx     4837 b- defN 24-May-11 14:22 zensols/mimic/regexnote.py
+-rw-rw-r--  2.0 unx     5808 b- defN 24-May-11 14:22 zensols/mimic/tokenizer.py
+-rw-r--r--  2.0 unx     2106 b- defN 24-May-11 14:22 zensols/mimic/resources/app.conf
+-rw-rw-r--  2.0 unx     2995 b- defN 24-May-11 14:22 zensols/mimic/resources/decorator.conf
+-rw-rw-r--  2.0 unx     1673 b- defN 24-May-11 14:22 zensols/mimic/resources/default.conf
+-rw-rw-r--  2.0 unx      368 b- defN 24-May-11 14:22 zensols/mimic/resources/obj.conf
+-rw-r--r--  2.0 unx      230 b- defN 24-May-11 14:22 zensols/mimic/resources/postgres.conf
+-rw-r--r--  2.0 unx     2569 b- defN 24-May-11 14:22 zensols/mimic/resources/conf/corpus.conf
+-rw-rw-r--  2.0 unx     1278 b- defN 24-May-11 14:22 zensols/mimic/resources/conf/lang.conf
+-rw-rw-r--  2.0 unx     2170 b- defN 24-May-11 14:22 zensols/mimic/resources/conf/note.conf
+-rw-rw-r--  2.0 unx     2662 b- defN 24-May-11 14:22 zensols/mimic/resources/conf/persist.conf
+-rw-rw-r--  2.0 unx      850 b- defN 24-May-11 14:22 zensols/mimic/resources/conf/remove-space.conf
+-rw-rw-r--  2.0 unx     1628 b- defN 24-May-11 14:22 zensols/mimic/resources/postgres/admission.sql
+-rw-rw-r--  2.0 unx     1218 b- defN 24-May-11 14:22 zensols/mimic/resources/postgres/icd.sql
+-rw-rw-r--  2.0 unx      161 b- defN 24-May-11 14:22 zensols/mimic/resources/postgres/medications.sql
+-rw-r--r--  2.0 unx     2349 b- defN 24-May-11 14:22 zensols/mimic/resources/postgres/note.sql
+-rw-rw-r--  2.0 unx      320 b- defN 24-May-11 14:22 zensols/mimic/resources/postgres/patient.sql
+-rw-r--r--  2.0 unx     1625 b- defN 24-May-11 14:22 zensols/mimic/resources/sqlite/admission.sql
+-rw-r--r--  2.0 unx     1216 b- defN 24-May-11 14:22 zensols/mimic/resources/sqlite/icd.sql
+-rw-r--r--  2.0 unx      160 b- defN 24-May-11 14:22 zensols/mimic/resources/sqlite/medications.sql
+-rw-r--r--  2.0 unx     2374 b- defN 24-May-11 14:22 zensols/mimic/resources/sqlite/note.sql
+-rw-rw-r--  2.0 unx      318 b- defN 24-May-11 14:22 zensols/mimic/resources/sqlite/patient.sql
+-rw-rw-r--  2.0 unx     7621 b- defN 24-May-11 14:22 zensols.mimic-1.7.1.dist-info/METADATA
+-rw-rw-r--  2.0 unx       92 b- defN 24-May-11 14:22 zensols.mimic-1.7.1.dist-info/WHEEL
+-rw-rw-r--  2.0 unx       45 b- defN 24-May-11 14:22 zensols.mimic-1.7.1.dist-info/entry_points.txt
+-rw-rw-r--  2.0 unx       14 b- defN 24-May-11 14:22 zensols.mimic-1.7.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     3243 b- defN 24-May-11 14:22 zensols.mimic-1.7.1.dist-info/RECORD
+36 files, 149643 bytes uncompressed, 44298 bytes compressed:  70.4%
```

## zipnote {}

```diff
@@ -87,23 +87,23 @@
 
 Filename: zensols/mimic/resources/sqlite/note.sql
 Comment: 
 
 Filename: zensols/mimic/resources/sqlite/patient.sql
 Comment: 
 
-Filename: zensols.mimic-1.7.0.dist-info/METADATA
+Filename: zensols.mimic-1.7.1.dist-info/METADATA
 Comment: 
 
-Filename: zensols.mimic-1.7.0.dist-info/WHEEL
+Filename: zensols.mimic-1.7.1.dist-info/WHEEL
 Comment: 
 
-Filename: zensols.mimic-1.7.0.dist-info/entry_points.txt
+Filename: zensols.mimic-1.7.1.dist-info/entry_points.txt
 Comment: 
 
-Filename: zensols.mimic-1.7.0.dist-info/top_level.txt
+Filename: zensols.mimic-1.7.1.dist-info/top_level.txt
 Comment: 
 
-Filename: zensols.mimic-1.7.0.dist-info/RECORD
+Filename: zensols.mimic-1.7.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## zensols/mimic/adm.py

```diff
@@ -42,18 +42,18 @@
 
     admission: Admission = field()
     """The admission of the admission."""
 
     patient: Patient = field()
     """The patient/subject."""
 
-    diagnoses: Tuple[Diagnosis] = field()
+    diagnoses: Tuple[Diagnosis, ...] = field()
     """The ICD-9 diagnoses of the hospital admission."""
 
-    procedures: Tuple[Procedure] = field()
+    procedures: Tuple[Procedure, ...] = field()
     """The ICD-9 procedures of the hospital admission."""
 
     def __post_init__(self):
         super().__init__()
 
     def _init(self, note_stash: Stash):
         self._note_stash = note_stash
@@ -66,25 +66,26 @@
     @property
     def notes(self) -> Iterable[Note]:
         """The notes by the care givers."""
         return iter(self._note_stash.values())
 
     @property
     @persisted('_by_category', transient=True)
-    def notes_by_category(self) -> Dict[str, Tuple[Note]]:
+    def notes_by_category(self) -> Dict[str, Tuple[Note, ...]]:
         """All notes by :obj:`.Note.category` as keys with the list of
         resepctive notes as a list as values.
 
         """
         notes = collections.defaultdict(list)
         for note in self.notes:
             notes[note.category].append(note)
         return frozendict({k: tuple(notes[k]) for k in notes.keys()})
 
-    def get_duplicate_notes(self, text_start: int = None) -> Tuple[Set[str]]:
+    def get_duplicate_notes(self, text_start: int = None) -> \
+            Tuple[Set[str], ...]:
         """Notes with the same note text, each in their respective set.
 
         :param text_start: the number of first N characters used to compare
                            notes, or the entire note text if ``None``
 
         :return: the duplicate note``row_id``, or if there are no duplicates,
                  an empty tuple
@@ -98,15 +99,15 @@
                 key = key[:text_start]
             dups[key].add(note.row_id)
         return tuple(map(lambda x: x[1], filter(
             lambda x: len(x[1]) > 1, dups.items())))
 
     def get_non_duplicate_notes(self, dup_sets: Tuple[Set[str]],
                                 filter_fn: Callable = None) -> \
-            Tuple[Tuple[Note, bool]]:
+            Tuple[Tuple[Note, bool], ...]:
         """Return non-duplicated notes.
 
         :param dup_sets: the duplicate sets generated from
                          :meth:`get_duplicate_notes`
 
         :param filer_fn: if provided it is used to filter duplicates; if
                          everything is filtered, a note from the respective
@@ -121,15 +122,15 @@
             if n.row_id in ds:
                 if filter_fn is not None:
                     return filter_fn(n)
                 return True
             else:
                 return False
 
-        notes: Tuple[Note] = self.notes
+        notes: Tuple[Note, ...] = self.notes
         dups: Set[str] = reduce(lambda x, y: x | y, dup_sets)
         # initialize with the notes not in any duplicate group, which are
         # non-duplicates
         non_dups: List[Note] = list(
             map(lambda x: (x, False),
                 filter(lambda n: n.row_id not in dups, notes)))
         ds: Set[str]
@@ -347,15 +348,15 @@
     """
     def __post_init__(self):
         super().__post_init__()
         self.strict = True
 
     def _create_note_stash(self, adm: Admission):
         np: NoteEventPersister = self.note_event_persister
-        row_ids: Tuple[int] = np.get_row_ids_by_hadm_id(adm.hadm_id)
+        row_ids: Tuple[int, ...] = np.get_row_ids_by_hadm_id(adm.hadm_id)
         return KeySubsetStash(
             delegate=self.note_stash,
             key_subset=set(map(str, row_ids)),
             dynamic_subset=False)
 
     def load(self, hadm_id: str) -> HospitalAdmission:
         """Create a *complete picture* of a hospital stay with admission,
@@ -367,16 +368,16 @@
         if logger.isEnabledFor(logging.DEBUG):
             logger.debug(f'loading hospital admission: {hadm_id}')
         hadm_id = int(hadm_id)
         dp: DiagnosisPersister = self.diagnosis_persister
         pp: ProcedurePersister = self.procedure_persister
         adm: Admission = self.admission_persister.get_by_hadm_id(hadm_id)
         pat: Patient = self.patient_persister.get_by_subject_id(adm.subject_id)
-        diag: Tuple[Diagnosis] = dp.get_by_hadm_id(hadm_id)
-        procds: Tuple[Procedure] = pp.get_by_hadm_id(hadm_id)
+        diag: Tuple[Diagnosis, ...] = dp.get_by_hadm_id(hadm_id)
+        procds: Tuple[Procedure, ...] = pp.get_by_hadm_id(hadm_id)
         note_stash: Stash = self._create_note_stash(adm)
         adm: HospitalAdmission = self.config_factory.new_instance(
             self.hospital_adm_name, adm, pat, diag, procds)
         adm._init(note_stash)
         return adm
 
     @persisted('_keys', cache_global=True)
@@ -442,15 +443,15 @@
     """The persister for the ``noteevents`` table."""
 
     adm_factory_stash: HospitalAdmissionDbFactoryStash = field(default=None)
     """The factory to create the admission instances."""
 
     def __post_init__(self):
         super().__post_init__()
-        self._row_ids: Tuple[str] = None
+        self._row_ids: Tuple[str, ...] = None
 
     def _create_data(self) -> Iterable[HospitalAdmission]:
         keys: Set[str] = self._row_ids
         if logger.isEnabledFor(logging.DEBUG):
             logger.debug(f'keys to process: {len(keys)}')
         return keys
 
@@ -502,15 +503,15 @@
                         f'existing: {len(existing_row_ids)}, ' +
                         f'create: {len(to_create_row_ids)}')
         if logger.isEnabledFor(logging.DEBUG):
             logger.debug(f'need: {self._row_ids}, ' +
                          f'existing: {existing_row_ids}, ' +
                          f'create: {to_create_row_ids}')
         # populate admissions that have at least one missing note
-        hadm_ids: Tuple[int] = tuple(np.get_hadm_ids(to_create_row_ids))
+        hadm_ids: Tuple[int, ...] = tuple(np.get_hadm_ids(to_create_row_ids))
         # first create the admissions to processes overwrite, only then can
         # notes be dervied from admissions and written across procs
         if logger.isEnabledFor(logging.INFO):
             logger.info(f'creating {len(hadm_ids)} cached admissions')
         hadm_id: int
         for hadm_id in hadm_ids:
             # force creation of the admission to cache the file
```

## zensols/mimic/note.py

```diff
@@ -96,14 +96,17 @@
 
     _SENT_FILTER_REGEX: ClassVar[re.Pattern] = re.compile(r'^\s*\d+\.\s*')
     """Remove enumerated lists (<number> .) as separate sentences.  Example is
     hadm=119960, cat=Discharge summary, section=Discharge Medications:
     ``1. Vancomycin 125 mg``.
 
     """
+    FILTER_ENUMS: ClassVar[bool] = True
+    """Whether to filter enumerated lists as separate sentences."""
+
     id: int = field()
     """The unique ID of the section."""
 
     name: Optional[str] = field()
     """The name of the section (i.e. ``hospital-course``).  This field is what's
     called the ``type`` in the paper, which is not used since ``type`` is a
     keyword in Python.
@@ -172,16 +175,18 @@
     @property
     @persisted('_body_doc', transient=True)
     def body_doc(self) -> FeatureDocument:
         """A feature document of the body of this section's body text."""
         return self._narrow_doc(self._get_doc(), self.body_span)
 
     def _narrow_doc(self, doc: FeatureDocument, span: LexicalSpan,
-                    filter_sent: bool = True) -> \
+                    filter_sent: bool = None) -> \
             FeatureDocument:
+        if filter_sent is None:
+            filter_sent = self.FILTER_ENUMS
         # using inclusive=true will very often leave newlines, but keep the last
         # sentence character when the sentence chunker gets confused
         doc = doc.get_overlapping_document(span, inclusive=True)
         if filter_sent:
             sreg: re.Pattern = self._SENT_FILTER_REGEX
             doc.sents = tuple(filter(lambda s: sreg.match(s.text) is None,
                                      doc.sents))
@@ -211,14 +216,28 @@
         return tuple(self._paragraph_factory.create(self))
 
     @property
     def is_empty(self) -> bool:
         """Whether the content of the section is empty."""
         return len(self.header_spans) == 0 and len(self.body.strip()) == 0
 
+    @staticmethod
+    def header_to_name(s: str) -> str:
+        """Convert a section header text to a section name."""
+        return s.replace(' ', '-').lower()
+
+    @staticmethod
+    def name_to_header(s: str) -> str:
+        """Convert a section name to a section header text.  Note that this uses
+        a heuristic method that might generate a string that does not match the
+        original header text.
+
+        """
+        return s.replace('-', ' ').capitalize()
+
     def _copy_resources(self, target: Section):
         for attr in self._PERSITABLE_TRANSIENT_ATTRIBUTES:
             setattr(target, attr, getattr(self, attr))
         target._row_id = self._row_id
 
     def clone(self) -> Section:
         clone = copy.copy(self)
@@ -336,14 +355,30 @@
     def _get_sections(self) -> Iterable[Section]:
         """Generate the sections cached and returned in the :obj:`sections`
         property.
 
         """
         pass
 
+    @staticmethod
+    def category_to_id(s: str) -> str:
+        """Convert a category string (i.e. ``Discharge summary``) to a category
+        ID (i.e. ``discharge-summary``).
+
+        """
+        return Section.header_to_name(s)
+
+    @staticmethod
+    def id_to_category(s: str) -> str:
+        """Convert a category ID (i.e. ``discharge-summary``) to a category
+        string (i.e. ``Discharge summary``).
+
+        """
+        return Section.name_to_header(s)
+
     @property
     @persisted('_sections')
     def sections(self) -> Dict[int, Section]:
         """A map from the unique section identifier to a note section.
 
         """
         secs: Iterable[Section] = self._get_sections()
```

## zensols/mimic/persist.py

```diff
@@ -1,17 +1,18 @@
 """Persisters for the MIMIC-III database.
 
 """
 __author__ = 'Paul Landes'
 
-from typing import Tuple, Iterable, Optional, List, Callable
+from typing import Tuple, List, Dict, Iterable, Optional, Callable
 from dataclasses import dataclass, field
 import logging
 import sys
 from itertools import chain
+from collections import defaultdict
 from zensols.config import Settings
 from zensols.persist import persisted, ReadOnlyStash, chunks
 from zensols.db import DbPersister
 from zensols.db.dataclass import DataClassDbPersister
 from zensols.db.sqlite import SqliteConnectionManager
 from zensols.nlp import FeatureDocument, FeatureDocumentParser
 from . import (
@@ -44,21 +45,21 @@
     def get_hadm_ids(self, subject_id: int) -> Iterable[int]:
         """Get all hospital admission IDs (``hadm_id``) for a patient."""
         ids = self.execute_by_name(
             'select_hadm_for_subject_id', params=(subject_id,),
             row_factory='tuple')
         return map(lambda x: x[0], ids)
 
-    def get_by_subject_id(self, subject_id: int) -> Tuple[Admission]:
+    def get_by_subject_id(self, subject_id: int) -> Tuple[Admission, ...]:
         """Get an admissions by patient ID."""
         return self.execute_by_name(
             'select_admission_by_subject_id', params=(subject_id,))
 
     def get_admission_counts(self, limit: int = sys.maxsize) -> \
-            Tuple[Tuple[int, int]]:
+            Tuple[Tuple[int, int], ...]:
         """Return the counts of subjects for each hospital admission.
 
         :param limit: the limit on the return admission counts
 
         :return: a list of tuples, each in the form (``subject_id``, ``count``)
 
         """
@@ -102,15 +103,15 @@
     def get_by_hadm_id(self, hadm_id: int) -> Diagnosis:
         """Get ICD-9 diagnoses codes by hospital admission IDs.
 
         """
         return self.execute_by_name(
             'select_diagnosis_by_hadm_id', params=(hadm_id,))
 
-    def get_heart_failure_hadm_ids(self) -> Tuple[int]:
+    def get_heart_failure_hadm_ids(self) -> Tuple[int, ...]:
         """Return hospital admission IDs that are heart failure related.
 
         """
         return tuple(map(lambda r: r[0],
                          self.execute_by_name('select_heart_failure_hadm_id',
                                               row_factory='tuple')))
 
@@ -187,15 +188,15 @@
         self.row_factory = self._create_bean
 
     def _create_bean(self, *args):
         return NoteEvent(*args, context=self.mimic_note_context)
 
     @property
     @persisted('_categories', cache_global=True)
-    def categories(self) -> Tuple[str]:
+    def categories(self) -> Tuple[str, ...]:
         """All unique categories."""
         cats = self.execute_by_name('categories', row_factory='tuple')
         return tuple(map(lambda x: x[0], cats))
 
     @property
     def _is_sqlite(self) -> bool:
         return isinstance(self.conn_manager, SqliteConnectionManager)
@@ -205,16 +206,20 @@
 
         :param hadm_id: the hospital admission ID
 
         """
         return self.execute_by_name(
             'select_note_count', params=(hadm_id,), row_factory='tuple')[0][0]
 
+    def get_note_counts(self) -> Tuple[int, ...]:
+        """Return the count of notes for all hospital admissions."""
+        return self.execute_by_name('select_note_counts', row_factory='tuple')
+
     def get_note_counts_by_subject_id(self, subject_id: int) -> \
-            Tuple[Tuple[int, int]]:
+            Tuple[Tuple[int, int], ...]:
         """Get counts of notes related to a subject.
 
         :param subject_id: the patient's ID
 
         :return: tuple of (``hadm_id``, ``count``) pairs for a subject
 
         """
@@ -225,46 +230,72 @@
     def get_row_ids_with_admissions(self) -> Iterable[int]:
         """Get note IDs associate with at least one admission."""
         return map(int, tuple(chain.from_iterable(
             self.execute_by_name(
                 'select_keys_with_adms',
                 row_factory='identity'))))
 
-    def get_row_ids_by_hadm_id(self, hadm_id: int) -> Tuple[int]:
+    def get_row_ids_by_hadm_id(self, hadm_id: int) -> Tuple[int, ...]:
         """Return all note row IDs for a admission ID."""
         hadm_ids = tuple(chain.from_iterable(
             self.execute_by_name(
                 'select_row_ids_by_hadm_id', params=(hadm_id,),
                 row_factory='identity')))
         if self._is_sqlite:
             hadm_ids = tuple(map(int, hadm_ids))
         return hadm_ids
 
-    def get_notes_by_hadm_id(self, hadm_id: int) -> Tuple[NoteEvent]:
+    def get_notes_by_hadm_id(self, hadm_id: int) -> Tuple[NoteEvent, ...]:
         """Return notes by hospital admission ID.
 
         :param hadm_id: the hospital admission ID
 
         """
         hadm_ids = self.execute_by_name(
             'select_notes_by_hadm_id', params=(hadm_id,))
         if self._is_sqlite:
             hadm_ids = tuple(map(int, hadm_ids))
         return hadm_ids
 
+    def get_row_ids_by_category(self, hadm_id: int,
+                                categories: Iterable[str]) -> \
+            Dict[str, List[int]]:
+        query_name: str = 'select_row_ids_by_hadm_id_category'
+        rows: Tuple[Tuple[int, str], ...]
+        by_cat: Dict[str, List[int]] = defaultdict(list)
+        cats: Tuple[str, ...] = tuple(categories)
+        if self._is_sqlite:
+            sql: str = self.sql_entries[query_name]
+            sql = sql.format(cats=','.join(['?'] * len(categories)))
+            # Python sqlite does not handle "where in" clauses
+            rows = self.execute(
+                sql,
+                row_factory='tuple',
+                params=(hadm_id, *cats))
+        else:
+            rows = self.execute_by_name(
+                query_name,
+                row_factory='tuple',
+                params=(hadm_id, cats))
+        row_id: int
+        cat: str
+        for row_id, cat in rows:
+            by_cat[cat].append(row_id)
+        return dict(by_cat.items())
+
     def get_hadm_id(self, row_id: int) -> Optional[int]:
         """Return the hospital admission for a note.
 
         :param row_id: the unique ID of the note event
 
         :return: the hospital admission unique ID ``hadm_id`` if ``row_id`` is
                  in the database
 
         """
-        maybe_row: Tuple[int] = self.execute_by_name(
+        maybe_row: Tuple[int, ...] = self.execute_by_name(
             'select_hadm_id_by_row_id', params=(row_id,),
             row_factory=lambda x: x)
         if len(maybe_row) > 0:
             if self._is_sqlite:
                 maybe_row = list(maybe_row)
                 maybe_row[0] = int(maybe_row[0])
             return maybe_row[0]
@@ -273,19 +304,19 @@
         """Return the hospital admission for a set of note.
 
         :param row_id: the unique IDs of the note events
 
         :return: the hospital admission admissions unique ID ``hadm_id``
 
         """
-        def map_chunk(ids: List[int]) -> Tuple[int]:
+        def map_chunk(ids: List[int]) -> Tuple[int, ...]:
             return self.execute_by_name(
                 sql_name, params=(tuple(ids),), row_factory=lambda x: x)
 
-        def map_chunk_sqlite(ids: List[int]) -> Tuple[int]:
+        def map_chunk_sqlite(ids: List[int]) -> Tuple[int, ...]:
             sql: str = self.sql_entries[sql_name]
             sql = sql.replace('?', f"({','.join(map(str, ids))})")
             return self.execute(sql, row_factory=lambda x: x)
 
         sql_name: str = 'select_hadm_id_by_row_ids'
         chunk_fn: Callable = map_chunk_sqlite if self._is_sqlite else map_chunk
         id_lsts: Iterable[List[int]] = chunks(row_ids, self.hadm_row_chunk_size)
@@ -295,16 +326,16 @@
         """Get all hospital admission IDs that have at least one associated
         note.
 
         """
         ids = self.execute_by_name('select_note_hadm_ids', row_factory='tuple')
         return map(lambda x: x[0], ids)
 
-    def get_notes_by_category(self, category: str,
-                              limit: int = sys.maxsize) -> Tuple[NoteEvent]:
+    def get_notes_by_category(self, category: str, limit: int = sys.maxsize) \
+            -> Tuple[NoteEvent, ...]:
         """Return notes by what the category to which they belong.
 
         :param category: the category of the note (i.e. ``Radiology``)
 
         :param limit: the limit of notes to return
 
         """
```

## zensols/mimic/resources/postgres/note.sql

```diff
@@ -24,14 +24,17 @@
 
 -- name=select_row_ids_by_hadm_id
 select row_id from noteevents where hadm_id = %s;
 
 -- name=select_categories_by_hadm_ids
 select hadm_id, row_id, category from noteevents where hadm_id in %s;
 
+-- name=select_row_ids_by_hadm_id_category
+select row_id, category from noteevents where hadm_id = %s and category in %s;
+
 -- name=select_hadm_id_by_row_id
 select hadm_id from noteevents where row_id = %s;
 
 -- name=select_hadm_id_by_row_ids
 select distinct(hadm_id) from noteevents where row_id in %s;
 
 -- name=select_keys
```

## zensols/mimic/resources/sqlite/admission.sql

```diff
@@ -29,15 +29,15 @@
     order by cnt desc
     limit ?;
 
 -- name=hadm_ids
 select hadm_id from admissions;
 
 -- name=select_hadm_id_exists
-select count(*) from admissions where hadm_id = ?;
+select count(*) > 0 from admissions where hadm_id = ?;
 
 -- get all noteevent IDs for heart patients
 select n.row_id, a.hadm_id, a.subject_id
     from admissions as a,
 	 noteevents as n
 	 where n.hadm_id = a.hadm_id and
 	       a.diagnosis in (
```

## zensols/mimic/resources/sqlite/note.sql

```diff
@@ -24,14 +24,19 @@
 
 -- name=select_row_ids_by_hadm_id
 select row_id from noteevents where hadm_id = ?;
 
 -- name=select_categories_by_hadm_ids
 select hadm_id, row_id, category from noteevents where hadm_id in ?;
 
+-- name=select_row_ids_by_hadm_id_category
+select row_id, category from noteevents
+    where hadm_id = ? and category in ({cats})
+    order by chartdate desc;
+
 -- name=select_hadm_id_by_row_id
 select hadm_id from noteevents where row_id = ?;
 
 -- name=select_hadm_id_by_row_ids
 select distinct(hadm_id) from noteevents where row_id in ?;
 
 -- name=select_keys
```

## Comparing `zensols.mimic-1.7.0.dist-info/METADATA` & `zensols.mimic-1.7.1.dist-info/METADATA`

 * *Files 3% similar despite different names*

```diff
@@ -1,27 +1,26 @@
 Metadata-Version: 2.1
 Name: zensols.mimic
-Version: 1.7.0
+Version: 1.7.1
 Summary: MIMIC III Corpus Parsing
 Home-page: https://github.com/plandes/mimic
-Download-URL: https://github.com/plandes/mimic/releases/download/v1.7.0/zensols.mimic-1.7.0-py3-none-any.whl
+Download-URL: https://github.com/plandes/mimic/releases/download/v1.7.1/zensols.mimic-1.7.1-py3-none-any.whl
 Author: Paul Landes
 Author-email: landes@mailc.net
 Keywords: tooling
 Description-Content-Type: text/markdown
 Requires-Dist: Pillow ~=10.1.0
 Requires-Dist: zensols.db ~=1.3.0
 Requires-Dist: zensols.mednlp ~=1.7.0
 
 # MIMIC III Corpus Parsing
 
 [![PyPI][pypi-badge]][pypi-link]
 [![Python 3.10][python310-badge]][python310-link]
 [![Python 3.11][python311-badge]][python311-link]
-[![Build Status][build-badge]][build-link]
 
 A utility library for parsing the [MIMIC-III] corpus.  This uses [spaCy] and
 extends the [zensols.mednlp] to parse the [MIMIC-III] medical note dataset.
 Features include:
 
 * Creates both natural language and medical features from medical notes.  The
   latter is generated using linked entity concepts parsed with [MedCAT] via
@@ -210,16 +209,14 @@
 [pypi]: https://pypi.org/project/zensols.mimic/
 [pypi-link]: https://pypi.python.org/pypi/zensols.mimic
 [pypi-badge]: https://img.shields.io/pypi/v/zensols.mimic.svg
 [python310-badge]: https://img.shields.io/badge/python-3.10-blue.svg
 [python310-link]: https://www.python.org/downloads/release/python-3100
 [python311-badge]: https://img.shields.io/badge/python-3.11-blue.svg
 [python311-link]: https://www.python.org/downloads/release/python-3110
-[build-badge]: https://github.com/plandes/mimic/workflows/CI/badge.svg
-[build-link]: https://github.com/plandes/mimic/actions
 
 [MIMIC-III]: https://physionet.org/content/mimiciii-demo/1.4/
 [MedCAT]: https://github.com/CogStack/MedCAT
 [spaCy]: https://spacy.io
 [zensols.mednlp]: https://github.com/plandes/mednlp
 
 [SQLite instructions]: https://github.com/MIT-LCP/mimic-code/tree/main/mimic-iii/buildmimic/sqlite
```

## Comparing `zensols.mimic-1.7.0.dist-info/RECORD` & `zensols.mimic-1.7.1.dist-info/RECORD`

 * *Files 25% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 zensols/mimic/__init__.py,sha256=aBhQImLOYucT3EaPcbp0PX5uy5W4Hm_jXQWE3WulKck,169
-zensols/mimic/adm.py,sha256=LKsxdTW-woe3n_D08UAUCTzHl99FG_mquwr66ySV3Fw,21058
+zensols/mimic/adm.py,sha256=pAOX9USrTtk8-jbtZ0P5u-QRdgwGljssZ3zN7tVqANg,21127
 zensols/mimic/app.py,sha256=80yuFYYeJFe_XVGIg0ugdxdDJgVWKC6qgUA8n3mRyYg,8433
 zensols/mimic/cli.py,sha256=3UOgcTroOl2DJACGW0nDfHNZ8NMc0vl_C1Tf4AL4WK4,828
 zensols/mimic/corpus.py,sha256=qr7C1twq6SO9zuZeZrYLrEsIaoqY6Ibo4CIXgphGsd0,5471
 zensols/mimic/domain.py,sha256=8V7Ar0Gc_NF8JcUn_Ebzop8y9kZ50OGupiFoE3uqcHc,15020
-zensols/mimic/note.py,sha256=IAoh9GQskM_c1D0FYMD1LMVr8GMgA85CTQ0jvbp4Nkw,29399
+zensols/mimic/note.py,sha256=wZ_YWqnhrXsJYk0Vi_AF-lW3WEMh4m6wbykIAc2dMIs,30524
 zensols/mimic/parafac.py,sha256=B1kle4vT8mj-HOYNc2t0HRUd581PmRSEzKsHmNdYP3o,5698
-zensols/mimic/persist.py,sha256=TcFj4BAJiScno5Z8n1zZaVHERoUgObPrNAg2sccA9SQ,11151
+zensols/mimic/persist.py,sha256=RXYPlU_nbaU0x_sqEw7PFlN6sF7KTztgjJCestrp0xQ,12443
 zensols/mimic/regexnote.py,sha256=XW7VgFJD1292GZCbPkYF3IPEZYoozje6FcvsFrN_GkY,4837
 zensols/mimic/tokenizer.py,sha256=BG193_6z1hwTTUcZCaDTPoxQdUrWVOnHinOiBRpYSNA,5808
 zensols/mimic/resources/app.conf,sha256=XIB5WpYCJdO4xZyD5mxocumMCBKaR3rvK5AIGcoaAVA,2106
 zensols/mimic/resources/decorator.conf,sha256=fMTE6CEg_qIh3AqUlxHpaYc4s5TWBfJwyMzCvJBZIb4,2995
 zensols/mimic/resources/default.conf,sha256=etXpsYFB4Hth0jDA73Pn8EKV_lccx7Uj-cXoel3O7MI,1673
 zensols/mimic/resources/obj.conf,sha256=dTNl8O7iaWPNJfRYWyGkDA1ES2EZcKuNIOxH_dVAMsM,368
 zensols/mimic/resources/postgres.conf,sha256=Pp-egSUsIxJnYRNMG7YL6KLG0KK2n6bsZGpUavR4GTA,230
@@ -18,19 +18,19 @@
 zensols/mimic/resources/conf/lang.conf,sha256=lxmLdPAMIvIkjJkCkzb9d_mbWOqsoGqEmVoCVzjZPZ8,1278
 zensols/mimic/resources/conf/note.conf,sha256=oV4lOUNzv9_aMNwl1uTPkz8FwduT1acvBU8Wnn0Ha_0,2170
 zensols/mimic/resources/conf/persist.conf,sha256=oA0ywHkRNs_bxY9P3pegOyWgWGH9i4OXGaBgGogAu_M,2662
 zensols/mimic/resources/conf/remove-space.conf,sha256=G0v_eDFR5GwwQNr1IGcFLtzNxNtuLcV-RJzGiCCtuJs,850
 zensols/mimic/resources/postgres/admission.sql,sha256=b8HpDYhD7gLf66baiTYOZnUEX3I41qDo8gJBnqBb33c,1628
 zensols/mimic/resources/postgres/icd.sql,sha256=pV8p_GATzWqbh3BRvhrX9rLSNOPjyASdWRdKGNCs-GQ,1218
 zensols/mimic/resources/postgres/medications.sql,sha256=8Ebgt_IF1rXqLbbbmeQcJg1oUMHYpU4KTMod6fubvFA,161
-zensols/mimic/resources/postgres/note.sql,sha256=Vd6vaK1debBABo7YpR90GJr2yQh4j85Li4x-AN98c3I,2226
+zensols/mimic/resources/postgres/note.sql,sha256=340BGy1GoYa6lrs3ZXgw8zHkB4gkBkY3UlFFywJU0DM,2349
 zensols/mimic/resources/postgres/patient.sql,sha256=x0bm411rPMJJxp6zujnaMLNP2EAJQbgVQ4vm7DiRGWg,320
-zensols/mimic/resources/sqlite/admission.sql,sha256=3KDmUw9hKZwKnV02g_6UvawXtGJioVXIa5mXzngGgCs,1621
+zensols/mimic/resources/sqlite/admission.sql,sha256=ciFCEyPJ6Rid134PlX8ZfjooDiGt43G76P8OEHgkOGg,1625
 zensols/mimic/resources/sqlite/icd.sql,sha256=rBrPyVNA0rRc_i5gA0veplXfi3K9-cvSgsZp-kVFIqM,1216
 zensols/mimic/resources/sqlite/medications.sql,sha256=KXdmrg9ypculD09QsREgrb4ws0PFmGqlPPgw__fOcL0,160
-zensols/mimic/resources/sqlite/note.sql,sha256=vEov-NvhwIe05Is-jzBNxWLlCyUx3elKUjA4XRqh8Ng,2214
+zensols/mimic/resources/sqlite/note.sql,sha256=frUEJAbdgy5ZyJjiMlrADZ8arY0UN-xIUMEM-7ErazY,2374
 zensols/mimic/resources/sqlite/patient.sql,sha256=PVHyujCJD9KVEP0Ql5tyScEk1Gh7I0JVSV5eJTVmc0Q,318
-zensols.mimic-1.7.0.dist-info/METADATA,sha256=L5FQe4xtNPXMFAmjiFEYqgQph0V3BYVFyJeEGMYlD4U,7790
-zensols.mimic-1.7.0.dist-info/WHEEL,sha256=oiQVh_5PnQM0E3gPdiz09WCNmwiHDMaGer_elqB3coM,92
-zensols.mimic-1.7.0.dist-info/entry_points.txt,sha256=9uACXuaRA0PkUS5F1T48QWcfiIoOhdnJu_VheNlRuHg,45
-zensols.mimic-1.7.0.dist-info/top_level.txt,sha256=IUsP4rDMhar7GriBPPNxw1jm5KDq136q96gT-GWk-cI,14
-zensols.mimic-1.7.0.dist-info/RECORD,,
+zensols.mimic-1.7.1.dist-info/METADATA,sha256=Ef0CTrEkNRONSp1mvA_6W1hLlPyeq-5NYaHQIGur16c,7621
+zensols.mimic-1.7.1.dist-info/WHEEL,sha256=oiQVh_5PnQM0E3gPdiz09WCNmwiHDMaGer_elqB3coM,92
+zensols.mimic-1.7.1.dist-info/entry_points.txt,sha256=9uACXuaRA0PkUS5F1T48QWcfiIoOhdnJu_VheNlRuHg,45
+zensols.mimic-1.7.1.dist-info/top_level.txt,sha256=IUsP4rDMhar7GriBPPNxw1jm5KDq136q96gT-GWk-cI,14
+zensols.mimic-1.7.1.dist-info/RECORD,,
```

