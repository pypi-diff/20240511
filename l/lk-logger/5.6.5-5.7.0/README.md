# Comparing `tmp/lk_logger-5.6.5-py3-none-any.whl.zip` & `tmp/lk_logger-5.7.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,31 +1,30 @@
-Zip file size: 42228 bytes, number of entries: 29
--rw-r--r--  2.0 fat      600 b- defN 80-Jan-01 00:00 lk_logger/__init__.py
--rw-r--r--  2.0 fat      616 b- defN 80-Jan-01 00:00 lk_logger/_print.py
+Zip file size: 42362 bytes, number of entries: 28
+-rw-r--r--  2.0 fat      680 b- defN 80-Jan-01 00:00 lk_logger/__init__.py
 -rw-r--r--  2.0 fat       34 b- defN 80-Jan-01 00:00 lk_logger/cache/__init__.py
 -rw-r--r--  2.0 fat     6970 b- defN 80-Jan-01 00:00 lk_logger/cache/cache.py
 -rw-r--r--  2.0 fat        0 b- defN 80-Jan-01 00:00 lk_logger/cache/frame.py
 -rw-r--r--  2.0 fat     1875 b- defN 80-Jan-01 00:00 lk_logger/cache/legacy.py
 -rw-r--r--  2.0 fat      762 b- defN 80-Jan-01 00:00 lk_logger/cache/util.py
--rw-r--r--  2.0 fat     5732 b- defN 80-Jan-01 00:00 lk_logger/config.py
--rw-r--r--  2.0 fat     1604 b- defN 80-Jan-01 00:00 lk_logger/console.py
--rw-r--r--  2.0 fat     4984 b- defN 80-Jan-01 00:00 lk_logger/control.py
--rw-r--r--  2.0 fat     7860 b- defN 80-Jan-01 00:00 lk_logger/frame_info.py
--rw-r--r--  2.0 fat    13703 b- defN 80-Jan-01 00:00 lk_logger/logger.py
+-rw-r--r--  2.0 fat     5815 b- defN 80-Jan-01 00:00 lk_logger/config.py
+-rw-r--r--  2.0 fat     1169 b- defN 80-Jan-01 00:00 lk_logger/console.py
+-rw-r--r--  2.0 fat     4988 b- defN 80-Jan-01 00:00 lk_logger/control.py
+-rw-r--r--  2.0 fat     8992 b- defN 80-Jan-01 00:00 lk_logger/frame_info.py
+-rw-r--r--  2.0 fat    13871 b- defN 80-Jan-01 00:00 lk_logger/logger.py
 -rw-r--r--  2.0 fat    10376 b- defN 80-Jan-01 00:00 lk_logger/markup.py
--rw-r--r--  2.0 fat    11468 b- defN 80-Jan-01 00:00 lk_logger/message_builder.py
--rw-r--r--  2.0 fat    11291 b- defN 80-Jan-01 00:00 lk_logger/message_formatter.py
+-rw-r--r--  2.0 fat    11434 b- defN 80-Jan-01 00:00 lk_logger/message_builder.py
+-rw-r--r--  2.0 fat    11258 b- defN 80-Jan-01 00:00 lk_logger/message_formatter.py
 -rw-r--r--  2.0 fat     4034 b- defN 80-Jan-01 00:00 lk_logger/path_helper.py
--rw-r--r--  2.0 fat     2656 b- defN 80-Jan-01 00:00 lk_logger/pipeline.py
+-rw-r--r--  2.0 fat     2658 b- defN 80-Jan-01 00:00 lk_logger/pipeline.py
+-rw-r--r--  2.0 fat     2690 b- defN 80-Jan-01 00:00 lk_logger/printer.py
 -rw-r--r--  2.0 fat       73 b- defN 80-Jan-01 00:00 lk_logger/scanner/__init__.py
 -rw-r--r--  2.0 fat     6407 b- defN 80-Jan-01 00:00 lk_logger/scanner/analyser.py
 -rw-r--r--  2.0 fat     1164 b- defN 80-Jan-01 00:00 lk_logger/scanner/const.py
 -rw-r--r--  2.0 fat     1780 b- defN 80-Jan-01 00:00 lk_logger/scanner/exceptions.py
--rw-r--r--  2.0 fat     9861 b- defN 80-Jan-01 00:00 lk_logger/scanner/scanner.py
--rw-r--r--  2.0 fat     3345 b- defN 80-Jan-01 00:00 lk_logger/scanner/symbols.py
+-rw-r--r--  2.0 fat     9728 b- defN 80-Jan-01 00:00 lk_logger/scanner/scanner.py
+-rw-r--r--  2.0 fat     3306 b- defN 80-Jan-01 00:00 lk_logger/scanner/symbols.py
 -rw-r--r--  2.0 fat    19638 b- defN 80-Jan-01 00:00 lk_logger/scanner/text_scanner.py
 -rw-r--r--  2.0 fat      517 b- defN 80-Jan-01 00:00 lk_logger/scanner/typehint.py
--rw-r--r--  2.0 fat      896 b- defN 80-Jan-01 00:00 lk_logger/shunt.py
--rw-r--r--  2.0 fat     4950 b- defN 80-Jan-01 00:00 lk_logger-5.6.5.dist-info/METADATA
--rw-r--r--  2.0 fat       88 b- defN 80-Jan-01 00:00 lk_logger-5.6.5.dist-info/WHEEL
-?rw-r--r--  2.0 fat     2324 b- defN 16-Jan-01 00:00 lk_logger-5.6.5.dist-info/RECORD
-29 files, 135608 bytes uncompressed, 38534 bytes compressed:  71.6%
+-rw-r--r--  2.0 fat     4952 b- defN 80-Jan-01 00:00 lk_logger-5.7.0.dist-info/METADATA
+-rw-r--r--  2.0 fat       88 b- defN 80-Jan-01 00:00 lk_logger-5.7.0.dist-info/WHEEL
+?rw-r--r--  2.0 fat     2252 b- defN 16-Jan-01 00:00 lk_logger-5.7.0.dist-info/RECORD
+28 files, 137511 bytes uncompressed, 38778 bytes compressed:  71.8%
```

## zipnote {}

```diff
@@ -1,13 +1,10 @@
 Filename: lk_logger/__init__.py
 Comment: 
 
-Filename: lk_logger/_print.py
-Comment: 
-
 Filename: lk_logger/cache/__init__.py
 Comment: 
 
 Filename: lk_logger/cache/cache.py
 Comment: 
 
 Filename: lk_logger/cache/frame.py
@@ -45,14 +42,17 @@
 
 Filename: lk_logger/path_helper.py
 Comment: 
 
 Filename: lk_logger/pipeline.py
 Comment: 
 
+Filename: lk_logger/printer.py
+Comment: 
+
 Filename: lk_logger/scanner/__init__.py
 Comment: 
 
 Filename: lk_logger/scanner/analyser.py
 Comment: 
 
 Filename: lk_logger/scanner/const.py
@@ -69,20 +69,17 @@
 
 Filename: lk_logger/scanner/text_scanner.py
 Comment: 
 
 Filename: lk_logger/scanner/typehint.py
 Comment: 
 
-Filename: lk_logger/shunt.py
-Comment: 
-
-Filename: lk_logger-5.6.5.dist-info/METADATA
+Filename: lk_logger-5.7.0.dist-info/METADATA
 Comment: 
 
-Filename: lk_logger-5.6.5.dist-info/WHEEL
+Filename: lk_logger-5.7.0.dist-info/WHEEL
 Comment: 
 
-Filename: lk_logger-5.6.5.dist-info/RECORD
+Filename: lk_logger-5.7.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## lk_logger/__init__.py

```diff
@@ -1,24 +1,26 @@
 from . import console
-from ._print import bprint
+from . import printer
 from .control import disable
 from .control import disable as mute
 from .control import enable
 from .control import enable as unmute
 from .control import setup
 from .control import start_ipython
 from .control import unload
 from .control import unload as restore_builtin_print
 from .control import update
 from .frame_info import FrameInfo
-from .logger import lk
+from .logger import logger
 from .pipeline import pipeline
+from .printer import bprint
+from .printer import parallel_printing
 
 
-def __init() -> None:
-    import traceback
-    pipeline.add(traceback, bprint)
-    setup(quiet=True)
-
-
-__init()
-__version__ = '5.6.5'
+# def __init() -> None:
+#     import traceback
+#     pipeline.add(traceback, bprint)
+#     setup(quiet=True)
+#
+#
+# __init()
+__version__ = '5.7.0'
```

## lk_logger/config.py

```diff
@@ -5,27 +5,27 @@
 
 class LoggingConfig:
     """
     options:
         show_source: bool[true]
             add source info (filepath and line number) prefix to log messages.
             example:
-                lk.log('hello world')
+                logger.log('hello world')
                 # enabled : './main.py:10  >>  hello world'
                 # disabled: 'hello world'
         show_varnames: bool[false]
             show both var names and values. (magic reflection)
             example:
                 a, b = 1, 2
-                lk.log(a, b, a + b)
+                logger.log(a, b, a + b)
                 # enabled : 'main.py:11  >>  a = 1; b = 2; a + b = 3'
                 # disabled: 'main.py:11  >>  1, 2, 3'
         show_external_lib: bool[true]
             if `param source` came from an external library, whether to print.
-            for example, if a third-party library 'xxx' also used `lk.log`,
+            for example, if a third-party library 'xxx' also used `logger.log`,
             its source path (relative to current working dir) may be very long,
             if you don't want to see any prints except your own project, you'd
             set this to False.
 
         # the following options are only available if `show_external_lib` is
         # true.
         path_style_for_external_lib: literal
@@ -58,15 +58,15 @@
     show_funcname: bool
     show_source: bool
     show_varnames: bool
     sourcemap_alignment: t.Literal['left', 'right']
     v2_meaning: t.Literal['info', 'success']  # TODO: not used.
     
     _preset_conf = {
-        'async_'                     : True,
+        'async_'                     : False,  # TODO
         'clear_unfinished_stream'    : False,
         'console_width'              : None,
         'path_style_for_external_lib': 'pretty_relpath',
         'rich_traceback'             : True,
         'separator'                  : ';   ',
         'show_external_lib'          : True,
         'show_funcname'              : True,
@@ -110,19 +110,20 @@
                     callback=modified
                 )
             else:
                 sys.excepthook = self._wrap_system_excepthook
     
     @staticmethod
     def _wrap_system_excepthook(
-            type_, value, traceback, callback=_default_excepthook
+        type_, value, traceback, callback=_default_excepthook
     ) -> None:
-        print(':r', '[red dim]drain out message queue[/]')
-        from .logger import lk
-        lk._stop_running()  # noqa
+        # print(':r', '[red dim]drain out message queue[/]')
+        # from .logger import logger
+        # if hasattr(logger, '_stop_running'):
+        #     logger._stop_running()  # noqa
         if type_ is KeyboardInterrupt:
             print(':r', '[red dim]KeyboardInterrupt[/]')
             sys.exit(0)
         else:
             callback(type_, value, traceback)
     
     # -------------------------------------------------------------------------
```

## lk_logger/console.py

```diff
@@ -1,18 +1,15 @@
-from functools import partial
 from typing import Any
 
 from rich.console import Console as BaseConsole
 
-__all__ = ['con_print', 'con_error', 'console']
-
 
 class Console(BaseConsole):
     
-    def __init__(self):
+    def __init__(self) -> None:
         super().__init__()
         if self._color_system is None:
             try:
                 # in rich version >= 12.5, the color system is changed to be a
                 # contant integer.
                 from rich.console import ColorSystem
                 self._color_system = ColorSystem.STANDARD
@@ -21,21 +18,16 @@
                 self._color_system = 'standard'
         
         # TODO (width):
         #   if width longer than default, use single line style; otherwise
         #   split sourcemap and message into different lines.
         pass
     
-    def print(self, *objects: Any, sep=" ", end="\n", style=None, justify=None,
-              overflow=None, no_wrap=None, emoji=None, markup=None,
-              highlight=None, width=None, height=None, crop=True,
-              soft_wrap=False, new_line_start=False, **_) -> None:
-        super().print(*objects, sep=sep, end=end, style=style, justify=justify,
-                      overflow=overflow, no_wrap=no_wrap, emoji=emoji,
-                      markup=markup, highlight=highlight, width=width,
-                      height=height, crop=crop, soft_wrap=soft_wrap,
-                      new_line_start=new_line_start)
+    def print(self, *objects: Any, soft_wrap: bool = True, **kwargs) -> None:
+        from .message_builder import MessageStruct
+        if len(objects) == 1 and isinstance(objects[0], MessageStruct):
+            super().print(objects[0].text, soft_wrap=soft_wrap, **kwargs)
+        else:
+            super().print(*objects, soft_wrap=soft_wrap, **kwargs)
 
 
 console = Console()
-con_print = partial(console.print, soft_wrap=True)
-con_error = console.print_exception
```

## lk_logger/control.py

```diff
@@ -1,19 +1,24 @@
 import builtins
 import typing as t
 
-from ._print import bprint
-from ._print import debug  # noqa
-from .logger import lk
+from .logger import logger
+from .printer import bprint
 
 STATUS = 'unloaded'  # literal['enabled', 'disabled', 'unloaded']
 _HAS_WELCOME_MESSAGE_SHOWN = False
 
 
-def setup(*, quiet=False, clear_preset=False, **kwargs) -> None:
+def setup(
+    *,
+    quiet: bool = False,
+    clear_preset: bool = False,
+    _stdout: t.Callable = None,  # TODO: experimental
+    **kwargs
+) -> None:
     """
     args:
         quiet:
             True: show a welcome message in caller side.
             False: do not show.
 
             note: the welcome message is shown only once, if caller calls this
@@ -22,69 +27,70 @@
             tip: if you are developing an intermediate/supporting library, it
                 is recommended to set `quiet=True`.
         clear_preset:
         kwargs: see `./logger.py > LoggingConfig`.
     """
     global _HAS_WELCOME_MESSAGE_SHOWN, STATUS
     
-    if _is_ipython_mode():
-        import IPython  # noqa
-        from .pipeline import pipeline
-        pipeline.add(IPython, bprint, scope=True)
-    
-    lk.configure(clear_preset, **kwargs)
-    setattr(builtins, 'print', lk.log)
+    logger.configure(clear_preset, **kwargs)
+    setattr(builtins, 'print', _stdout or logger.log)
     
     if not quiet and not _HAS_WELCOME_MESSAGE_SHOWN:
         _HAS_WELCOME_MESSAGE_SHOWN = True
         
         from .markup import _Counter
         random_color = _Counter._get_random_bright_color  # noqa
         color_pair = (random_color(), random_color())
-        slogan = _blend_text('♥ lk-logger is ready', color_pair)
+        slogan = _blend_text('lk-logger is ready', color_pair)
 
         # from random import choice
         # color_pairs_group = (
         #     ('#0a87ee', '#9294f0'),  # calm blue -> light blue
         #     ('#2d34f1', '#9294f0'),  # ocean blue -> light blue
         #     ('#ed3b3b', '#d08bf3'),  # rose red -> violet
         #     ('#f38cfd', '#d08bf3'),  # light magenta -> violet
         #     ('#f47fa4', '#f49364'),  # cold sandy -> camel tan
         # )
         # color_pair = choice(color_pairs_group)
-        # slogan = _blend_text('♥ lk-logger is ready', color_pair)
+        # slogan = _blend_text('lk-logger is ready', color_pair)
         
-        # debug(slogan)
+        # dprint(slogan)
         print(slogan, ':rsp')
     
     STATUS = 'enabled'
 
 
 def update(clear_preset=False, **kwargs) -> None:
-    lk.configure(clear_preset, **kwargs)
+    logger.configure(clear_preset, **kwargs)
 
 
 def unload() -> None:
     setattr(builtins, 'print', bprint)
     global STATUS
     STATUS = 'unloaded'
 
 
 def enable() -> None:
-    setattr(builtins, 'print', lk.log)
+    setattr(builtins, 'print', logger.log)
     global STATUS
     STATUS = 'enabled'
 
 
 def disable() -> None:
     setattr(builtins, 'print', lambda *_, **__: None)
     global STATUS
     STATUS = 'disabled'
 
 
+# aliases
+mute = disable
+unmute = enable
+reload = enable
+
+
 # -----------------------------------------------------------------------------
 # other
 
 def start_ipython(
         user_ns: t.Dict[str, t.Any] = None
 ) -> None:
     if _is_ipython_mode():
@@ -101,35 +107,35 @@
         from rich.traceback import install
         from .console import console
         from .pipeline import pipeline
     
     pipeline.add(IPython, bprint, scope=True)
     
     backups = {
-        'lklogger_config': lk.config.copy(),
+        'lklogger_config': logger.config.copy(),
         'sys.argv'       : sys.argv.copy(),
     }
     
     setup(quiet=True, clear_preset=True,
           show_source=False, show_funcname=False, show_varnames=False)
     sys.argv = ['']  # avoid ipython to parse `sys.argv`.
     
     app = TerminalIPythonApp.instance(
-        user_ns={'print': lk.log, **(user_ns or {})}
+        user_ns={'print': logger.log, **(user_ns or {})}
     )
     app.initialize()
     
     # setup except hook for ipython
     setattr(builtins, 'get_ipython', get_ipython)
     install(console=console)
     
     app.start()
     
     # afterwards
-    lk.configure(**backups['lklogger_config'])
+    logger.configure(**backups['lklogger_config'])
     sys.argv = backups['sys.argv']
     del backups
 
 
 # -----------------------------------------------------------------------------
 # neutral functions
```

### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

## lk_logger/frame_info.py

```diff
@@ -1,10 +1,11 @@
 import inspect
 import re
 import typing as t
+from dataclasses import dataclass
 from os.path import abspath
 from os.path import exists
 from textwrap import dedent
 from types import FrameType
 
 from .scanner import get_all_blocks
 from .scanner import get_variables
@@ -198,11 +199,57 @@
     def funcname(self) -> str:
         return self._frame.f_code.co_name
     
     def collect_varnames(self) -> T.VarNames:
         return sourcemap.get_varnames(self.filepath, self.lineno)
     
     def get_parent(self, traceback_level: int = 1) -> 'FrameInfo':
-        frame = self._frame
-        for _ in range(traceback_level):
-            frame = frame.f_back
-        return FrameInfo(frame)
+        return FrameInfo(_get_parent_frame(self._frame, traceback_level))
+
+
+@dataclass
+class FrozenFrameInfo:
+    """
+    this is picklable. used for multiprocessing queue.
+    """
+    filepath: str
+    lineno: int
+    indentation: int
+    funcname: str
+    _parent: 'FrozenFrameInfo' = None
+
+    @property
+    def id(self) -> str:
+        return f'{self.filepath}:{self.lineno}'
+
+    def collect_varnames(self) -> T.VarNames:
+        return sourcemap.get_varnames(self.filepath, self.lineno)
+    
+    def get_parent(self, _) -> 'FrozenFrameInfo':
+        assert self._parent
+        return self._parent
+
+
+def freeze_frame_info(
+    frame: FrameType,
+    _traceback_level: int = 0,
+) -> FrozenFrameInfo:
+    info = FrameInfo(frame)
+    return FrozenFrameInfo(
+        info.filepath,
+        info.lineno,
+        info.indentation,
+        info.funcname,
+        (
+            _traceback_level > 0
+            and freeze_frame_info(
+                _get_parent_frame(frame, _traceback_level)
+            )
+            or None
+        )
+    )
+
+
+def _get_parent_frame(frame: FrameType, level: int = 1) -> FrameType:
+    for _ in range(level):
+        frame = frame.f_back
+    return frame
```

## lk_logger/logger.py

```diff
@@ -1,33 +1,33 @@
+import atexit
 import typing as t
-from atexit import register
 from collections import deque
 from inspect import currentframe
 from threading import Thread
 from time import sleep
 
 from rich.console import RenderableType
 from rich.traceback import Traceback
 
-from ._print import bprint
-from ._print import debug  # noqa
 from .cache import LoggingCache
 from .config import LoggingConfig
-from .console import con_print
 from .frame_info import FrameInfo
+from .frame_info import FrozenFrameInfo
 from .markup import MarkMeaning
 from .markup import MarkupAnalyser
 from .markup import T as T0
 from .message_builder import MessageStruct
 from .message_builder import T as T1
 from .message_builder import builder as message_builder
 from .path_helper import path_helper
 from .pipeline import pipeline
-from .shunt import Shunt
-from .shunt import T as T2
+from .printer import con_print
+from .printer import dbg_print  # noqa
+from .printer import printer_manager
+from .printer import std_print
 
 
 class _RawArgs:  # a workaround. see its usage below.
     def __init__(self, args: t.Tuple[t.Any, ...]):
         self.args = args
 
 
@@ -42,191 +42,105 @@
         t.Type[_NoMessage], _RawArgs
     ]
     FlushScheme = int
     #   0: no flush
     #   1: instant flush
     #   2: instant flush and drain
     #   3: wait for flush
+    FrameInfo = t.Union[FrameInfo, FrozenFrameInfo]
     Info = T1.Info
     Markup = T0.Markup
     MarkupPos = int  # -1, 0, 1
-    Pipe = T2.Pipe
-    PipeId = T2.PipeId
 
 
-class LKLogger:
+class MainThreadedLogger:
     
-    def __init__(self):
+    def __init__(self) -> None:
         self._analyser = MarkupAnalyser()
         self._cache = LoggingCache()
         self._config = LoggingConfig()
-        
-        self._shunt = Shunt()
-        # self._shunt.add(con_print)
-        self.add_pipe = self._shunt.add
-        self.remove_pipe = self._shunt.remove
-        
-        self._running = False
-        self._message_queue = deque()
-        register(self._stop_running)
-        self._thread = Thread(target=self._start_running)
-        self._thread.daemon = True
-        self._thread.start()
     
-    def configure(self, clear_preset=False, **kwargs) -> None:
+    def configure(self, clear_preset: bool = False, **kwargs) -> None:
         self._cache.clear_cache()
         if clear_preset:
             self._config.reset()
         if 'show_varname' in kwargs:  # workaround for compatibility
             kwargs['show_varnames'] = kwargs.pop('show_varname')
         self._config.update(**kwargs)
-        message_builder.update_config(
-            separator=self._config.separator,
-        )
+        message_builder.update_config(separator=self._config.separator)
     
     @property
     def config(self) -> dict:
         return self._config.to_dict()
     
-    def _start_running(self) -> None:
-        
-        def consume() -> None:
-            msg: t.Union[str, tuple]
-            kwargs: dict
-            custom_print: t.Optional[t.Callable]
-            
-            for i in range(len(self._message_queue)):
-                if not self._message_queue: break
-                msg, kwargs, custom_print = self._message_queue.popleft()
-                if custom_print:
-                    # debug(custom_print, msg, kwargs)
-                    kwargs.pop('file', None)
-                    custom_print(*msg, **kwargs)
-                else:
-                    self._cprint(msg, **kwargs)
-                    self._dprint(msg)
-        
-        self._running = True
-        while self._running:
-            if self._message_queue:
-                consume()
-            else:
-                sleep(10E-3)
-        else:
-            consume()
-    
-    def _stop_running(self) -> None:
-        if self._config.clear_unfinished_stream:
-            self._message_queue.clear()
-        self._running = False
-        self._thread.join()
-    
     # -------------------------------------------------------------------------
     
     def log(
-            self,
-            *args: t.Any,
-            _frame_info: FrameInfo = None,
-            **kwargs
+        self,
+        *args: t.Any,
+        _frame_info: T.FrameInfo = None,
+        **kwargs
     ) -> None:
         if _frame_info is None:
             _frame_info = FrameInfo(currentframe().f_back)
-            # debug(_frame_info.info)
+            # dprint(_frame_info.info)
         
-        if (path := _frame_info.filepath) \
-                and (custom_print := pipeline.get(path)):
-            if self._config.async_:
-                self._message_queue.append((args, kwargs, custom_print))
-            else:
-                custom_print(*args, **kwargs)
+        if (
+            (path := _frame_info.filepath) and
+            (custom_print := pipeline.get(path))
+        ):
+            custom_print(*args, **kwargs)
             return
         
         msg, flush_scheme = self._build_message(_frame_info, *args)
         if msg is _NoMessage: return
         is_raw = isinstance(msg, _RawArgs)
-        # debug(msg)
+        # dprint(msg)
         
-        self._print(msg, flush_scheme, _is_raw=is_raw, **kwargs)
+        self._print(msg, _is_raw=is_raw, **kwargs)
     
     def _print(
-            self,
-            msg: T.ComposedMessage,
-            flush_scheme: T.FlushScheme = 0,
-            _is_raw: bool = False,
-            **kwargs
+        self, msg: T.ComposedMessage, _is_raw: bool = False, **kwargs
     ) -> None:
-        if flush_scheme == 0:
-            if self._config.async_:
-                if _is_raw:
-                    self._message_queue.append((msg.args, kwargs, bprint))
-                else:
-                    self._message_queue.append((msg, kwargs, None))
-            else:
-                if _is_raw:
-                    self._bprint(msg, **kwargs)
-                else:
-                    self._cprint(msg, **kwargs)
-                    self._dprint(msg)
-        elif flush_scheme == 1:
-            while self._message_queue:
-                sleep(10E-3)
-            if _is_raw:
-                self._bprint(msg, **kwargs)
-            else:
-                self._cprint(msg, **kwargs)
-                self._dprint(msg)
-        elif flush_scheme == 2:
-            if skipped_count := len(self._message_queue):
-                self._message_queue.clear()
-                print(':frp2', f'[red dim](... skipped '
-                               f'{skipped_count} messages)[/]')
-            if _is_raw:
-                self._bprint(msg, **kwargs)
-            else:
-                self._cprint(msg, **kwargs)
-                self._dprint(msg)
-        elif flush_scheme == 3:
-            if _is_raw:
-                self._bprint(msg, **kwargs)
-            else:
-                self._cprint(msg, **kwargs)
-                self._dprint(msg)
+        if _is_raw:
+            self._bprint(msg, **kwargs)
         else:
-            raise ValueError(flush_scheme)
+            self._cprint(msg, **kwargs)
+            self._dprint(msg)
     
     @staticmethod
     def _bprint(msg: _RawArgs, **kwargs) -> None:
-        bprint(*msg.args, **kwargs)
+        std_print(*msg.args, **kwargs)
     
     @staticmethod
     def _cprint(msg: T.ComposedMessage, **kwargs) -> None:
         if isinstance(msg, MessageStruct):
-            con_print(msg.text, **kwargs)
-        else:
-            con_print(msg, **kwargs)
+            msg = msg.text
+        con_print(msg, **kwargs)
     
-    def _dprint(self, msg: T.ComposedMessage) -> None:
-        if self._shunt:
-            if isinstance(msg, MessageStruct):
-                for caller in self._shunt:
-                    caller(msg.body.plain)
+    @staticmethod
+    def _dprint(msg: T.ComposedMessage) -> None:
+        if isinstance(msg, MessageStruct):
+            msg = msg.body.plain
+        for p in printer_manager.printers:
+            p(msg)
     
     # FIXME
     def fmt(self, _frame_info: FrameInfo = None, *args, **_) -> str:
         return str(self._build_message(
             _frame_info or FrameInfo(currentframe().f_back), *args
         )[0])
     
     # -------------------------------------------------------------------------
     
     def _build_message(
-            self, frame_info: FrameInfo, *args
+        self, frame_info: T.FrameInfo, *args
     ) -> t.Tuple[T.ComposedMessage, T.FlushScheme]:
         args, markup_pos, markup = \
-            self._extract_markup_from_arguments(frame_info.id, args)
+            self._separate_markup_from_arguments(frame_info.id, args)
         marks = self._analyser.extract(markup)
         
         get_varnames = frame_info.collect_varnames  # backup method pointer
         if marks['p']: frame_info = frame_info.get_parent(marks['p'])
         marks_meaning = self._analyser.analyze(marks, frame_info=frame_info)
         del marks
         
@@ -248,16 +162,18 @@
                 self._config.show_varnames,
                 self._config.sourcemap_alignment,
             ), flush_scheme
         
         # ---------------------------------------------------------------------
         
         if not args:
-            if MarkMeaning.MODERATE_PRUNE in marks_meaning or \
-                    MarkMeaning.AGRESSIVE_PRUNE in marks_meaning:
+            if (
+                MarkMeaning.MODERATE_PRUNE in marks_meaning or
+                MarkMeaning.AGRESSIVE_PRUNE in marks_meaning
+            ):
                 return _NoMessage, flush_scheme
         if MarkMeaning.BUILTIN_PRINT in marks_meaning:
             return _RawArgs(args), flush_scheme
         elif MarkMeaning.RICH_OBJECT in marks_meaning:
             assert len(args) == 1 and isinstance(args[0], RenderableType)
             return args[0], flush_scheme
         elif MarkMeaning.TRACEBACK_EXCEPTION in marks_meaning:
@@ -276,25 +192,25 @@
             'line_number'    : '0',
             'is_external_lib': False,
             'function_name'  : '',
             'variable_names' : (),
         }
         
         show_source = (
-                self._config.show_source and
-                (MarkMeaning.AGRESSIVE_PRUNE not in marks_meaning)
+            self._config.show_source and
+            (MarkMeaning.AGRESSIVE_PRUNE not in marks_meaning)
         )
         show_funcname = (
-                self._config.show_funcname and
-                (MarkMeaning.AGRESSIVE_PRUNE not in marks_meaning)
+            self._config.show_funcname and
+            (MarkMeaning.AGRESSIVE_PRUNE not in marks_meaning)
         )
         show_varnames = (
-                self._config.show_varnames and
-                MarkMeaning.MODERATE_PRUNE not in marks_meaning and
-                MarkMeaning.AGRESSIVE_PRUNE not in marks_meaning
+            self._config.show_varnames and
+            MarkMeaning.MODERATE_PRUNE not in marks_meaning and
+            MarkMeaning.AGRESSIVE_PRUNE not in marks_meaning
         )
         
         if any((show_source, show_funcname, show_varnames)):
             if show_source:
                 def update_sourcemap():
                     """
                     this function updates follows:
@@ -339,44 +255,140 @@
             args, marks_meaning, info,
             show_source=show_source,
             show_funcname=show_funcname,
             show_varnames=show_varnames,
             sourcemap_alignment=self._config.sourcemap_alignment,
         ), flush_scheme
     
-    def _extract_markup_from_arguments(
-            self, frame_id: str, args: T.Args
+    def _separate_markup_from_arguments(
+        self, frame_id: str, args: T.Args
     ) -> t.Tuple[T.Args, T.MarkupPos, T.Markup]:
         """
         return: (args, markup_pos, markup)
             markup_pos: which position of `markup` in `args`.
                 0 not exists, 1 first place, -1 last place.
         """
         if (markup_pos := self._cache.get_markup_pos(frame_id)) is None:
             is_markup = self._analyser.is_valid_markup
             if (
-                    len(args) > 0 and
-                    isinstance(args[0], str) and
-                    args[0].startswith(':') and
-                    is_markup(args[0])
+                len(args) > 0 and
+                isinstance(args[0], str) and
+                args[0].startswith(':') and
+                is_markup(args[0])
             ):
                 markup_pos = 1
             elif (
-                    len(args) > 1 and
-                    isinstance(args[-1], str) and
-                    args[-1].startswith(':') and
-                    is_markup(args[-1])
+                len(args) > 1 and
+                isinstance(args[-1], str) and
+                args[-1].startswith(':') and
+                is_markup(args[-1])
             ):
                 markup_pos = -1
             else:
                 markup_pos = 0
             self._cache.record_markup_pos(frame_id, markup_pos)
         
         if markup_pos == 0:
             return args, markup_pos, ''
         elif markup_pos == 1:
             return args[1:], markup_pos, args[0]
         else:
             return args[:-1], markup_pos, args[-1]
 
 
-lk = LKLogger()
+class SubThreadedLogger(MainThreadedLogger):
+    # TODO: not enabled in v5.7.0
+    
+    def __init__(self) -> None:
+        super().__init__()
+        self._running = False
+        self._message_queue = deque()
+        atexit.register(self._stop_running)
+        self._thread = Thread(target=self._start_running)
+        self._thread.daemon = True
+        self._thread.start()
+    
+    def _start_running(self) -> None:
+        
+        def consume() -> None:
+            msg: t.Union[str, tuple]
+            kwargs: dict
+            custom_print: t.Optional[t.Callable]
+            
+            for i in range(len(self._message_queue)):
+                if not self._message_queue: break
+                msg, kwargs, custom_print = self._message_queue.popleft()
+                if custom_print:
+                    # dprint(custom_print, msg, kwargs)
+                    kwargs.pop('file', None)
+                    custom_print(*msg, **kwargs)
+                else:
+                    self._cprint(msg, **kwargs)
+                    self._dprint(msg)
+        
+        self._running = True
+        while self._running:
+            if self._message_queue:
+                consume()
+            else:
+                sleep(10E-3)
+        else:
+            consume()
+    
+    def _stop_running(self) -> None:
+        if self._config.clear_unfinished_stream:
+            self._message_queue.clear()
+        self._running = False
+        self._thread.join()
+    
+    # -------------------------------------------------------------------------
+    
+    def _print(
+        self,
+        msg: T.ComposedMessage,
+        flush_scheme: T.FlushScheme = 0,
+        _is_raw: bool = False,
+        **kwargs
+    ) -> None:
+        if flush_scheme == 0:
+            if self._config.async_:
+                if _is_raw:
+                    self._message_queue.append((msg.args, kwargs, std_print))
+                else:
+                    self._message_queue.append((msg, kwargs, None))
+            else:
+                if _is_raw:
+                    self._bprint(msg, **kwargs)
+                else:
+                    self._cprint(msg, **kwargs)
+                    self._dprint(msg)
+        elif flush_scheme == 1:
+            while self._message_queue:
+                sleep(10E-3)
+            if _is_raw:
+                self._bprint(msg, **kwargs)
+            else:
+                self._cprint(msg, **kwargs)
+                self._dprint(msg)
+        elif flush_scheme == 2:
+            if skipped_count := len(self._message_queue):
+                self._message_queue.clear()
+                print(
+                    ':frp2',
+                    f'[red dim](... skipped {skipped_count} messages)[/]'
+                )
+            if _is_raw:
+                self._bprint(msg, **kwargs)
+            else:
+                self._cprint(msg, **kwargs)
+                self._dprint(msg)
+        elif flush_scheme == 3:
+            if _is_raw:
+                self._bprint(msg, **kwargs)
+            else:
+                self._cprint(msg, **kwargs)
+                self._dprint(msg)
+        else:
+            raise ValueError(flush_scheme)
+
+
+logger = MainThreadedLogger()
```

## lk_logger/message_builder.py

```diff
@@ -1,15 +1,14 @@
 import typing as t
 
 from rich.console import Group
 from rich.padding import Padding  # DELETE
 from rich.text import Text
 from rich.traceback import Traceback
 
-from ._print import debug  # noqa
 from .console import console
 from .markup import MarkMeaning
 from .markup import T as T0
 from .message_formatter import formatter
 
 
 class MessageStruct:
@@ -25,15 +24,15 @@
     @property
     def text(self) -> t.Union[Text, Group, Padding]:
         if self.head:
             if not self._reverse:
                 return Text.assemble(self.head, self.body)
             else:
                 con_width = console.width - 2
-                # debug(con_width)
+                # dprint(con_width)
                 if con_width <= len(self.head):  # fallback
                     if '\n' not in self.body:
                         self.body.pad_left(2)
                         return self.body
                     else:
                         lines = self.body.split()
                         for x in lines:
```

## lk_logger/message_formatter.py

```diff
@@ -13,15 +13,14 @@
 from rich._inspect import Inspect
 from rich.console import RenderableType
 # from rich.padding import Padding
 from rich.pretty import pretty_repr
 from rich.text import Text
 from rich.traceback import Traceback
 
-from ._print import debug  # noqa
 from .console import console
 
 strftime = lambda t: (t and _strftime('%H:%M:%S', localtime(t))) or ''
 
 
 @dataclass
 class MarkupText:
@@ -326,15 +325,15 @@
         varnames: t.Tuple[str, ...],
     ) -> t.Iterable[str]:
         if not arguments:
             return ()
         try:
             assert len(varnames) == len(arguments), (varnames, arguments)
         except AssertionError:
-            # debug('failed extracting varnames')
+            # dprint('failed extracting varnames')
             return map(str, arguments)
         else:
             return (f'{v} = {a}' if v else str(a)
                     for v, a in zip(varnames, arguments))
     
     # @staticmethod
     # def _mix_arguments_with_varnames(
@@ -342,15 +341,15 @@
     #         varnames: t.Tuple[str, ...],
     # ) -> t.Iterator[t.Tuple[str, t.Any]]:
     #     if not arguments:
     #         return
     #     try:
     #         assert len(varnames) == len(arguments), (varnames, arguments)
     #     except AssertionError:
-    #         # debug('failed extracting varnames')
+    #         # dprint('failed extracting varnames')
     #         for arg in arguments:
     #             yield '', arg
     #     else:
     #         yield from zip(varnames, arguments)
     
     @staticmethod
     def _fmt_width(text: str, min_width: int = None, step_space=4) -> str:
```

## lk_logger/pipeline.py

```diff
@@ -1,16 +1,16 @@
 from __future__ import annotations
 
 import typing as t
 from os import name as _os_name
 from os.path import abspath
 from os.path import dirname
 
-from ._print import bprint
-from ._print import debug  # noqa
+from .printer import bprint
+# from .printer import dprint
 
 
 class T:
     PrintFunc = t.Optional[t.Callable]
     Cache = t.Dict[str, PrintFunc]
     PipeLines = t.NamedTuple('PipeLines2', (
         ('abspath', t.Dict[str, PrintFunc]),
@@ -41,41 +41,41 @@
         if isinstance(x, str):
             if x.startswith('['):
                 path = x
             else:
                 path = _normpath(x)
         else:
             # x is a package or a module
-            # debug(x, x.__file__)
+            # dprint(x, x.__file__)
             path = _normpath(x.__file__)
             if scope:
                 path = dirname(path)
-        # debug('add path to pipeline', path)
+        # dprint('add path to pipeline', path)
         if prt is None:
             prt = _mute_print
         if path.startswith('['):
             self._lines.libname[path] = prt
         else:
             self._lines.abspath[path] = prt
         self._cache[path] = prt
     
     def get(self, path: str) -> T.PrintFunc:
         """
         get proper print function for the given path.
         """
         # the path is an absolute path.
         path = _normpath(path)
-        # debug(path)
+        # dprint(path)
         if path in self._cache:
-            # debug('path in cache', path, self._cache[path])
+            # dprint('path in cache', path, self._cache[path])
             return self._cache[path]
         for root, prt in self._lines.abspath.items():
             if path.startswith(root):
                 self._cache[path] = prt
-                # debug('use custom print', path)
+                # dprint('use custom print', path)
                 return prt
         self._cache[path] = None
         return None
 
 
 class _MutePrint:
     def __call__(self, *_, **__):
```

## lk_logger/scanner/scanner.py

```diff
@@ -6,15 +6,15 @@
 from re import compile
 from string import whitespace
 
 from .analyser import Analyser
 from .const import *
 from .exceptions import *
 from .typehint import *
-from .._print import debug  # noqa
+from ..printer import dprint  # noqa
 
 
 def get_all_blocks(*lines: str, end_mark='\n'):
     """ Get ALL COMPLETE text blocks.
     
     Scanning lines and try to merge the adjacent incomplete lines. If the
     merged result is a complete block (type: `list[str]`), yield it to the
@@ -69,15 +69,15 @@
                 continue
             elif ret_code == BREAK_OUT:
                 # `BREAK_OUT` is recognized as continuously sending `CONTINUE`
                 # command, until we meet an `end_mark` then break.
                 while char != end_mark:
                     cursor.update_charno()
                     char = line_[cursor.charno]
-                    # debug(cursor.charno, char)
+                    # dprint(cursor.charno, char)
                 yield from _submit()
                 break
             elif ret_code == UNREACHABLE_CASE:
                 raise UnreachableCase(
                     cursor.i, line, cursor.j, char, analyser.symbols
                 )
             else:
@@ -106,15 +106,15 @@
         start, end = match0.span()  # exterior brackets span
         line = line[start + 1:end].rstrip(whitespace + ',')
         #   `~.rstrip(...)`: for example:
         #       line = 'a, b, c, \n' -> 'a, b, c'
         
         for match1 in get_all_blocks(line, end_mark=','):
             element = match1.fulltext.strip()
-            # debug(f'{element = }')
+            # dprint(f'{element = }')
             
             if not element:
                 # # continue
                 raise ScanningError(
                     match1.cursor.lineno, line,
                     match1.cursor.charno, (line + ',')[match1.cursor.tileno],
                     None
@@ -170,17 +170,14 @@
             else:
                 yield element, VARIABLE_NAME
         
         break
 
 
 def _debug(linex, line, charx, char, symbols=None):
-    # from lk_logger_3_6 import lk
-    # lk.logt('[D4011]', visualize_line(
-    #     linex, line, charx, char, symbols), h='parent')
     print(visualize_line(linex, line, charx, char, symbols))
 
 
 class Match:
     
     def __init__(self, cursor: Union[TCursor, tuple],
                  text: str, matches: TMatches2):
```

## lk_logger/scanner/symbols.py

```diff
@@ -67,25 +67,25 @@
         # noinspection PyUnusedLocal
         def loop(master, node, pos_s, pos_e, start, end):
             for i in range(start, end):
                 if i in consumed:
                     continue
                 pos_i = pos_list[i]
                 pos_o = matches[pos_i]
-                # lk.logt('[D1605]', pos_i, pos_o, 'field range', pos_s, pos_e)
+                # debug(pos_i, pos_o, 'field range', pos_s, pos_e)
                 
                 if pos_o < pos_e:
-                    # lk.logt('[D1427]', 'subset of node', pos_i, pos_o, node)
+                    # debug('subset of node', pos_i, pos_o, node)
                     loop(
                         master=node, node=node.setdefault((pos_i, pos_o), {}),
                         pos_s=pos_i, pos_e=pos_o,
                         start=i + 1, end=find_nearest_index(pos_o, i + 1)
                     )
                 else:
-                    # lk.logt('[D1453]', 'adjacent to node', pos_i, pos_o, master)
+                    # debug('adjacent to node', pos_i, pos_o, master)
                     loop(
                         master=master, node=master.setdefault((pos_i, pos_o), {}),
                         pos_s=pos_i, pos_e=pos_o,
                         start=i + 1, end=find_nearest_index(pos_o, i + 1)
                     )
                 consumed.append(i)
```

## Comparing `lk_logger-5.6.5.dist-info/METADATA` & `lk_logger-5.7.0.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 Metadata-Version: 2.1
 Name: lk-logger
-Version: 5.6.5
-Summary: Python advanced print with varnames.
+Version: 5.7.0
+Summary: Python print with source and varnames.
 Home-page: https://github.com/likianta/lk-logger
 License: MIT
 Author: Likianta
 Author-email: likianta@foxmail.com
 Requires-Python: >=3.8,<4.0
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Programming Language :: Python :: 3
```

## Comparing `lk_logger-5.6.5.dist-info/RECORD` & `lk_logger-5.7.0.dist-info/RECORD`

 * *Files 18% similar despite different names*

```diff
@@ -1,29 +1,28 @@
-lk_logger/__init__.py,sha256=nIVmeLZa5uIDcoHQ4O2bbWTl5FxZBr8_D2-GUqn8NxI,600
-lk_logger/_print.py,sha256=vr_kODnH9vZU-r6MSLpgQxoRt2SxsVT-bzVP0nIxIsU,616
+lk_logger/__init__.py,sha256=x7IpyoD9eNBYN6b45Nea9Rl--gf5nt1JfOBmpDUU6ZE,680
 lk_logger/cache/__init__.py,sha256=jkWi40WfmTt3Akv3YKjJHI6gxPqzXwpFmdF4bIJ-SUs,34
 lk_logger/cache/cache.py,sha256=b2zusDBHjbAVtoP8CdBedPvkujVjNosUNlsUiCPSJeY,6970
 lk_logger/cache/frame.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 lk_logger/cache/legacy.py,sha256=kuQrFzJGuTd_NQWrO5Vp6b-Da3X73w60Ae2LxVP3Xb8,1875
 lk_logger/cache/util.py,sha256=6qtnnIhdrKTqyP4Elxd1d3OnkTFROzxAGWYz3c4smDk,762
-lk_logger/config.py,sha256=dNjNYrh9fn1mC5xi48BxuRAPuEfvYjDj3JCupoXHEmo,5732
-lk_logger/console.py,sha256=O7t06PiIe5P3A1ZTYQV-KOg2-N0eWloqSpbd0s_fvhk,1604
-lk_logger/control.py,sha256=xGpGI2ZYIfANsJsd1vqXZne1YU7vUfGqZlu-FAujRxY,4984
-lk_logger/frame_info.py,sha256=wLnmzGfNXGXEqDikodPUe8JHMi9dHXtdT2CEkiGDp-M,7860
-lk_logger/logger.py,sha256=N2ncmmsqC7ovELajcpwjaaO29q4JA-HDEiCMmLyofyw,13703
+lk_logger/config.py,sha256=jIB5tc1Eqke8_TGrCiropibesY5dBvyHzur_FtKOYdA,5815
+lk_logger/console.py,sha256=2iDM02xilIILLhjhf7zyp8pYb-SwokCs2HY54EtFsnE,1169
+lk_logger/control.py,sha256=60G6mzfj7TH6BL07BTzz5ShrzhbUXJpTcZYt2_fvVSE,4988
+lk_logger/frame_info.py,sha256=MFeZoRq8ou5-5m77N40xOO3ADOxNMdWRcn4-EUouQqA,8992
+lk_logger/logger.py,sha256=EMLUj3h6C5d4Vj423GBhB5lvGAdLTt_pA1ebvq2GBD0,13871
 lk_logger/markup.py,sha256=WkIaQIRDwUyYZFY-Jn22qc-Ig7fJyx6V6jYawZcnnYQ,10376
-lk_logger/message_builder.py,sha256=sVrOtJMQi9JmowCR-zWF2WJggRQ8xXTpoRvsppogQ3Q,11468
-lk_logger/message_formatter.py,sha256=iT869b9P6eReA5j4vI4yk9m6W4t9HUenxDOKrhsos2c,11291
+lk_logger/message_builder.py,sha256=--BtpkikTZXdEbZm1_-dJSxhAiE1E20GWpIIgSm5Nzc,11434
+lk_logger/message_formatter.py,sha256=lpv_rB616EmHLqYaYt7SirNIndvAdbPD9H1ZWrLthbQ,11258
 lk_logger/path_helper.py,sha256=LAZOe5XK_51I0YPA6rUuY0_DKtaMtHyz52xcHqRbxY0,4034
-lk_logger/pipeline.py,sha256=WmKrflsI6VXqFcUq60iaySHjhFcPw0UEml0jZmHe7lU,2656
+lk_logger/pipeline.py,sha256=qhgbvYUYLot6aCNMiRZRTtWrXrwWlh1y49uLrGQui9w,2658
+lk_logger/printer.py,sha256=X9baNbtuLRLK3R43CNbcyvJTA7e6cyXa2b_zDXuNxTQ,2690
 lk_logger/scanner/__init__.py,sha256=2b0jy5SdPwiVQSV9kL_3Vd4AkbKrRp7npAUWC3Hbyek,73
 lk_logger/scanner/analyser.py,sha256=y3HuYB2DJ4ixwww4c9o6Jq6mPc2eqz88w5Cf84_Pf6E,6407
 lk_logger/scanner/const.py,sha256=npj77J2VntzHArQOaIUIj9IeRQi9hH33_lo2XYLlg-s,1164
 lk_logger/scanner/exceptions.py,sha256=G1wpgEIzTLLrD6Q_m0qGD85v5KnlPm3CV1ZxgvGCVd8,1780
-lk_logger/scanner/scanner.py,sha256=F9lS4doo9MvCn9gRRaSR5cJ_hnVQUV2dvq0dbuxjQbg,9861
-lk_logger/scanner/symbols.py,sha256=4Od09HWEBXe6xsPfBfwV5pMsUJYPkLyoEEneV93HzjA,3345
+lk_logger/scanner/scanner.py,sha256=I9tf-ELQOLgZxWM5YNCEP5FvW5JkmIhfVEdhezXGz4M,9728
+lk_logger/scanner/symbols.py,sha256=FhLqVbYRG-a72ZoVgriP4FKmAhweyeyh02IkiLymT2I,3306
 lk_logger/scanner/text_scanner.py,sha256=84ese30Bh-H1ZVxT0jcNhsTwM1nLDkZOrUO1LSdjV6k,19638
 lk_logger/scanner/typehint.py,sha256=CdX-02JvaI8PkEHgTN279e081njEAfNOHaxPXCQkguc,517
-lk_logger/shunt.py,sha256=lqC61T3Txo2L-rDmlA1VdFp9aTEkoNSOCh8Y2l6-kRI,896
-lk_logger-5.6.5.dist-info/METADATA,sha256=swvTebTGlZy0VrjH9B3zS7H29oSXkSfg_thpVUmIGHA,4950
-lk_logger-5.6.5.dist-info/WHEEL,sha256=sP946D7jFCHeNz5Iq4fL4Lu-PrWrFsgfLXbbkciIZwg,88
-lk_logger-5.6.5.dist-info/RECORD,,
+lk_logger-5.7.0.dist-info/METADATA,sha256=9YTOj4QYufaG4jH1fFL7a5xZC1_bNyMjfBeeYZj3K74,4952
+lk_logger-5.7.0.dist-info/WHEEL,sha256=sP946D7jFCHeNz5Iq4fL4Lu-PrWrFsgfLXbbkciIZwg,88
+lk_logger-5.7.0.dist-info/RECORD,,
```

