# Comparing `tmp/asknews-0.5.5-py3-none-any.whl.zip` & `tmp/asknews-0.6.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,26 +1,26 @@
-Zip file size: 22592 bytes, number of entries: 24
--rw-r--r--  2.0 unx      263 b- defN 80-Jan-01 00:00 asknews_sdk/__init__.py
+Zip file size: 23530 bytes, number of entries: 24
+-rw-r--r--  2.0 unx      262 b- defN 80-Jan-01 00:00 asknews_sdk/__init__.py
 -rw-r--r--  2.0 unx      415 b- defN 80-Jan-01 00:00 asknews_sdk/api/__init__.py
--rw-r--r--  2.0 unx     4442 b- defN 80-Jan-01 00:00 asknews_sdk/api/analytics.py
--rw-r--r--  2.0 unx      170 b- defN 80-Jan-01 00:00 asknews_sdk/api/base.py
--rw-r--r--  2.0 unx     8437 b- defN 80-Jan-01 00:00 asknews_sdk/api/chat.py
--rw-r--r--  2.0 unx    11705 b- defN 80-Jan-01 00:00 asknews_sdk/api/news.py
--rw-r--r--  2.0 unx    10473 b- defN 80-Jan-01 00:00 asknews_sdk/api/stories.py
--rw-r--r--  2.0 unx    15904 b- defN 80-Jan-01 00:00 asknews_sdk/client.py
--rw-r--r--  2.0 unx      740 b- defN 80-Jan-01 00:00 asknews_sdk/dto/__init__.py
--rw-r--r--  2.0 unx     2430 b- defN 80-Jan-01 00:00 asknews_sdk/dto/base.py
--rw-r--r--  2.0 unx     3981 b- defN 80-Jan-01 00:00 asknews_sdk/dto/chat.py
--rw-r--r--  2.0 unx      606 b- defN 80-Jan-01 00:00 asknews_sdk/dto/error.py
--rw-r--r--  2.0 unx     1284 b- defN 80-Jan-01 00:00 asknews_sdk/dto/news.py
--rw-r--r--  2.0 unx      552 b- defN 80-Jan-01 00:00 asknews_sdk/dto/sentiment.py
--rw-r--r--  2.0 unx     4200 b- defN 80-Jan-01 00:00 asknews_sdk/dto/stories.py
--rw-r--r--  2.0 unx     1414 b- defN 80-Jan-01 00:00 asknews_sdk/errors.py
--rw-r--r--  2.0 unx     6274 b- defN 80-Jan-01 00:00 asknews_sdk/sdk.py
--rw-r--r--  2.0 unx     5248 b- defN 80-Jan-01 00:00 asknews_sdk/security.py
--rw-r--r--  2.0 unx     1583 b- defN 80-Jan-01 00:00 asknews_sdk/utils.py
+-rw-r--r--  2.0 unx     4569 b- defN 80-Jan-01 00:00 asknews_sdk/api/analytics.py
+-rw-r--r--  2.0 unx      203 b- defN 80-Jan-01 00:00 asknews_sdk/api/base.py
+-rw-r--r--  2.0 unx     8720 b- defN 80-Jan-01 00:00 asknews_sdk/api/chat.py
+-rw-r--r--  2.0 unx    13185 b- defN 80-Jan-01 00:00 asknews_sdk/api/news.py
+-rw-r--r--  2.0 unx    10988 b- defN 80-Jan-01 00:00 asknews_sdk/api/stories.py
+-rw-r--r--  2.0 unx    16134 b- defN 80-Jan-01 00:00 asknews_sdk/client.py
+-rw-r--r--  2.0 unx      677 b- defN 80-Jan-01 00:00 asknews_sdk/dto/__init__.py
+-rw-r--r--  2.0 unx     3805 b- defN 80-Jan-01 00:00 asknews_sdk/dto/base.py
+-rw-r--r--  2.0 unx     4530 b- defN 80-Jan-01 00:00 asknews_sdk/dto/chat.py
+-rw-r--r--  2.0 unx      674 b- defN 80-Jan-01 00:00 asknews_sdk/dto/error.py
+-rw-r--r--  2.0 unx     1296 b- defN 80-Jan-01 00:00 asknews_sdk/dto/news.py
+-rw-r--r--  2.0 unx      588 b- defN 80-Jan-01 00:00 asknews_sdk/dto/sentiment.py
+-rw-r--r--  2.0 unx     6643 b- defN 80-Jan-01 00:00 asknews_sdk/dto/stories.py
+-rw-r--r--  2.0 unx     1451 b- defN 80-Jan-01 00:00 asknews_sdk/errors.py
+-rw-r--r--  2.0 unx     6339 b- defN 80-Jan-01 00:00 asknews_sdk/sdk.py
+-rw-r--r--  2.0 unx     5396 b- defN 80-Jan-01 00:00 asknews_sdk/security.py
+-rw-r--r--  2.0 unx     1614 b- defN 80-Jan-01 00:00 asknews_sdk/utils.py
 -rw-r--r--  2.0 unx       22 b- defN 80-Jan-01 00:00 asknews_sdk/version.py
--rw-r--r--  2.0 unx     1073 b- defN 80-Jan-01 00:00 asknews-0.5.5.dist-info/LICENSE
--rw-r--r--  2.0 unx     3185 b- defN 80-Jan-01 00:00 asknews-0.5.5.dist-info/METADATA
--rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 asknews-0.5.5.dist-info/WHEEL
-?rw-r--r--  2.0 unx     1901 b- defN 16-Jan-01 00:00 asknews-0.5.5.dist-info/RECORD
-24 files, 86390 bytes uncompressed, 19558 bytes compressed:  77.4%
+-rw-r--r--  2.0 unx     1073 b- defN 80-Jan-01 00:00 asknews-0.6.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     3236 b- defN 80-Jan-01 00:00 asknews-0.6.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 asknews-0.6.0.dist-info/WHEEL
+?rw-r--r--  2.0 unx     1901 b- defN 16-Jan-01 00:00 asknews-0.6.0.dist-info/RECORD
+24 files, 93809 bytes uncompressed, 20496 bytes compressed:  78.2%
```

## zipnote {}

```diff
@@ -54,20 +54,20 @@
 
 Filename: asknews_sdk/utils.py
 Comment: 
 
 Filename: asknews_sdk/version.py
 Comment: 
 
-Filename: asknews-0.5.5.dist-info/LICENSE
+Filename: asknews-0.6.0.dist-info/LICENSE
 Comment: 
 
-Filename: asknews-0.5.5.dist-info/METADATA
+Filename: asknews-0.6.0.dist-info/METADATA
 Comment: 
 
-Filename: asknews-0.5.5.dist-info/WHEEL
+Filename: asknews-0.6.0.dist-info/WHEEL
 Comment: 
 
-Filename: asknews-0.5.5.dist-info/RECORD
+Filename: asknews-0.6.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## asknews_sdk/__init__.py

```diff
@@ -1,9 +1,10 @@
-# flake8: noqa
+# ruff: noqa
 import warnings
+
 warnings.filterwarnings("ignore", category=UserWarning)
 
 from asknews_sdk.version import __version__
 from asknews_sdk.sdk import AskNewsSDK, AsyncAskNewsSDK
 
 __all__ = (
     "__version__",
```

## asknews_sdk/api/__init__.py

```diff
@@ -1,11 +1,11 @@
 from asknews_sdk.api.analytics import AnalyticsAPI, AsyncAnalyticsAPI
-from asknews_sdk.api.stories import StoriesAPI, AsyncStoriesAPI
-from asknews_sdk.api.news import NewsAPI, AsyncNewsAPI
-from asknews_sdk.api.chat import ChatAPI, AsyncChatAPI
+from asknews_sdk.api.chat import AsyncChatAPI, ChatAPI
+from asknews_sdk.api.news import AsyncNewsAPI, NewsAPI
+from asknews_sdk.api.stories import AsyncStoriesAPI, StoriesAPI
 
 __all__ = (
     "AnalyticsAPI",
     "AsyncAnalyticsAPI",
     "StoriesAPI",
     "AsyncStoriesAPI",
     "NewsAPI",
```

## asknews_sdk/api/analytics.py

```diff
@@ -1,19 +1,21 @@
 from datetime import datetime
-from typing import Literal
+from typing import Literal, Optional, Union
+
 from asknews_sdk.api.base import BaseAPI
 from asknews_sdk.dto.sentiment import FinanceResponse
 
 
 class AnalyticsAPI(BaseAPI):
     """
     Analytics API
 
     https://docs.asknews.app/en/reference#tag--analytics
     """
+
     def get_asset_sentiment(
         self,
         asset: Literal[
             "bitcoin",
             "ethereum",
             "cardano",
             "uniswap",
@@ -26,40 +28,40 @@
             "dogecoin",
             "monero",
             "tron",
             "binance",
             "aave",
             "tesla",
             "microsoft",
-            "amazon"
+            "amazon",
         ],
         metric: Literal[
             "news_positive",
             "news_negative",
             "news_total",
             "news_positive_weighted",
             "news_negative_weighted",
             "news_total_weighted",
         ] = "news_positive",
-        date_from: datetime | str | None = None,
-        date_to: datetime | str | None = None,
+        date_from: Optional[Union[datetime, str]] = None,
+        date_to: Optional[Union[datetime, str]] = None,
     ) -> FinanceResponse:
         """
         Get the timeseries sentiment for an asset.
 
         https://docs.asknews.app/en/reference#get-/v1/analytics/finance/sentiment
 
         :param slug: The asset slug.
         :type slug: str
         :param metric: The sentiment metric.
         :type metric: str
         :param date_from: The start date in ISO format.
-        :type date_from: str | datetime
+        :type date_from: Optional[Union[str, datetime]]
         :param date_to: The end date in ISO format.
-        :type date_to: str | datetime
+        :type date_to: Optional[Union[str, datetime]]
         :return: The sentiment response.
         :rtype: FinanceResponse
         """
         if isinstance(date_from, datetime):
             date_from = date_from.isoformat()
         if isinstance(date_to, datetime):
             date_to = date_to.isoformat()
@@ -67,26 +69,28 @@
         response = self.client.request(
             method="GET",
             endpoint="/v1/analytics/finance/sentiment",
             query={
                 "asset": asset,
                 "metric": metric,
                 "date_from": date_from,
-                "date_to": date_to
+                "date_to": date_to,
             },
-            accept=[(FinanceResponse.__content_type__, 1.0)]
+            accept=[(FinanceResponse.__content_type__, 1.0)],
         )
         return FinanceResponse.model_validate(response.content)
 
+
 class AsyncAnalyticsAPI(BaseAPI):
     """
     Analytics API
 
     https://docs.asknews.app/en/reference#tag--analytics
     """
+
     async def get_asset_sentiment(
         self,
         asset: Literal[
             "bitcoin",
             "ethereum",
             "cardano",
             "uniswap",
@@ -99,40 +103,40 @@
             "dogecoin",
             "monero",
             "tron",
             "binance",
             "aave",
             "tesla",
             "microsoft",
-            "amazon"
+            "amazon",
         ],
         metric: Literal[
             "news_positive",
             "news_negative",
             "news_total",
             "news_positive_weighted",
             "news_negative_weighted",
             "news_total_weighted",
         ] = "news_positive",
-        date_from: datetime | str | None = None,
-        date_to: datetime | str | None = None,
+        date_from: Optional[Union[datetime, str]] = None,
+        date_to: Optional[Union[datetime, str]] = None,
     ) -> FinanceResponse:
         """
         Get the timeseries sentiment for an asset.
 
         https://docs.asknews.app/en/reference#get-/v1/analytics/finance/sentiment
 
         :param slug: The asset slug.
         :type slug: str
         :param metric: The sentiment metric.
         :type metric: str
         :param date_from: The start date in ISO format.
-        :type date_from: str | datetime
+        :type date_from: Optional[Union[str, datetime]]
         :param date_to: The end date in ISO format.
-        :type date_to: str | datetime
+        :type date_to: Optional[Union[str, datetime]]
         :return: The sentiment response.
         :rtype: FinanceResponse
         """
         if isinstance(date_from, datetime):
             date_from = date_from.isoformat()
         if isinstance(date_to, datetime):
             date_to = date_to.isoformat()
@@ -140,12 +144,12 @@
         response = await self.client.request(
             method="GET",
             endpoint="/v1/analytics/finance/sentiment",
             query={
                 "asset": asset,
                 "metric": metric,
                 "date_from": date_from,
-                "date_to": date_to
+                "date_to": date_to,
             },
-            accept=[(FinanceResponse.__content_type__, 1.0)]
+            accept=[(FinanceResponse.__content_type__, 1.0)],
         )
         return FinanceResponse.model_validate(response.content)
```

## asknews_sdk/api/base.py

```diff
@@ -1,5 +1,8 @@
+from typing import Union
+
 from asknews_sdk.client import APIClient, AsyncAPIClient
 
+
 class BaseAPI:
-    def __init__(self, client: APIClient | AsyncAPIClient) -> None:
+    def __init__(self, client: Union[APIClient, AsyncAPIClient]) -> None:
         self.client = client
```

## asknews_sdk/api/chat.py

```diff
@@ -1,49 +1,56 @@
-from typing import AsyncIterator, Iterator, Literal
+from typing import AsyncIterator, Dict, Iterator, List, Literal, Optional, Union
 
 from asknews_sdk.api.base import BaseAPI
 from asknews_sdk.dto.chat import (
     CreateChatCompletionRequest,
     CreateChatCompletionResponse,
     CreateChatCompletionResponseStream,
     ListModelResponse,
 )
 
+
 class ChatAPI(BaseAPI):
     """
     Chat API
 
     https://add-docs.review.docs.asknews.app/en/reference#tag--chat
     """
+
     def get_chat_completions(
         self,
-        messages: list[dict[str, str]],
+        messages: List[Dict[str, str]],
         model: Literal[
             "gpt-3.5-turbo-16k",
             "gpt-4-1106-preview",
             "mistral-small",
-            "mixtral-8x7b-32768"
+            "mixtral-8x7b-32768",
         ] = "gpt-3.5-turbo-16k",
         stream: bool = False,
-    ) -> CreateChatCompletionResponse | Iterator[CreateChatCompletionResponseStream]:
+    ) -> Union[
+        CreateChatCompletionResponse, Iterator[CreateChatCompletionResponseStream]
+    ]:
         """
         Get chat completions for a given user message.
 
         https://docs.asknews.app/en/reference#post-/v1/openai/chat/completions
 
         :param messages: List of messages in the conversation.
-        :type messages: list[dict[str, str]]
+        :type messages: List[Dict[str, str]]
         :param model: Model to use for chat completion, defaults to "gpt-3.5-turbo-16k"
         :type model: Literal[
-            "gpt-3.5-turbo-16k", "gpt-4-1106-preview", "mistral-small", "mixtral-8x7b-32768"
+            "gpt-3.5-turbo-16k", "gpt-4-1106-preview", "mistral-small",
+            "mixtral-8x7b-32768"
         ]
         :param stream: Whether to stream the response, defaults to False
         :type stream: bool
         :return: Chat completions
-        :rtype: CreateChatCompletionResponse | Iterator[CreateChatCompletionResponseStream]
+        :rtype: Union[
+            CreateChatCompletionResponse, Iterator[CreateChatCompletionResponseStream]
+        ]
         """
         response = self.client.request(
             method="POST",
             endpoint="/v1/openai/chat/completions",
             body=CreateChatCompletionRequest(
                 messages=messages,
                 model=model,
@@ -53,26 +60,29 @@
                 "Content-Type": CreateChatCompletionRequest.__content_type__,
             },
             accept=[
                 (CreateChatCompletionResponse.__content_type__, 1.0),
                 (CreateChatCompletionResponseStream.__content_type__, 1.0),
             ],
             stream=stream,
-            stream_type="lines"  # type: ignore
+            stream_type="lines",  # type: ignore
         )
 
         if stream:
+
             def _stream():
                 for chunk in response.content:
                     if chunk.strip() == "data: [DONE]":
                         break
 
                     if chunk.startswith("data:"):
                         json_data = chunk.replace("data: ", "").strip()
-                        yield CreateChatCompletionResponseStream.model_validate_json(json_data)
+                        yield CreateChatCompletionResponseStream.model_validate_json(
+                            json_data
+                        )
 
             return _stream()
         else:
             return CreateChatCompletionResponse.model_validate(response.content)
 
     def list_chat_models(self) -> ListModelResponse:
         """
@@ -82,81 +92,90 @@
 
         :return: List of available chat models
         :rtype: ListModelResponse
         """
         response = self.client.request(
             method="GET",
             endpoint="/v1/openai/chat/models",
-            accept=[(ListModelResponse.__content_type__, 1.0)]
+            accept=[(ListModelResponse.__content_type__, 1.0)],
         )
         return ListModelResponse.model_validate(response.content)
 
-    def get_headline_questions(self, queries: list[str] | None = None) -> dict[str, list[str]]:
+    def get_headline_questions(
+        self, queries: Optional[List[str]] = None
+    ) -> Dict[str, List[str]]:
         """
         Get headline questions for a given query.
 
         https://docs.asknews.app/en/reference#get-/v1/chat/questions
 
         :param queries: List of queries to get headline questions for
-        :type queries: list[str] | None
+        :type queries: Optional[List[str]]
         :return: Headline questions
-        :rtype: dict[str, list[str]]
+        :rtype: Dict[str, List[str]]
         """
         response = self.client.request(
-            method="GET",
-            endpoint="/v1/chat/questions",
-            query={"queries": queries}
+            method="GET", endpoint="/v1/chat/questions", query={"queries": queries}
         )
         return response.content
 
 
 class AsyncChatAPI(BaseAPI):
     """
     Chat API
 
     https://api.asknews.app/docs#tag/chat
     """
+
     async def get_chat_completions(
         self,
-        messages: list[dict[str, str]],
+        messages: List[Dict[str, str]],
         model: Literal[
             "gpt-3.5-turbo-16k",
             "gpt-4-turbo-2024-04-09",
             "open-mixtral-8x7b",
             "meta-llama/Meta-Llama-3-70B-Instruct",
         ] = "gpt-3.5-turbo-16k",
         stream: bool = False,
-        inline_citations: Literal["markdown_link", "numbered", "none"] = "markdown_link",
+        inline_citations: Literal[
+            "markdown_link", "numbered", "none"
+        ] = "markdown_link",
         append_references: bool = True,
         asknews_watermark: bool = True,
         journalist_mode: bool = True,
         temperature: float = 0.5,
         top_p: float = 1,
         n: int = 1,
-        stop: str | list[str] | None = None,
+        stop: Optional[Union[str, List[str]]] = None,
         max_tokens: int = 1000,
         presence_penalty: float = 0,
         frequency_penalty: float = 0,
-        user: str | None = None,
-    ) -> CreateChatCompletionResponse | AsyncIterator[CreateChatCompletionResponseStream]:
+        user: Optional[str] = None,
+    ) -> Union[
+        CreateChatCompletionResponse, AsyncIterator[CreateChatCompletionResponseStream]
+    ]:
         """
         Get chat completions for a given user message.
 
         https://docs.asknews.app/en/reference#post-/v1/openai/chat/completions
 
         :param messages: List of messages in the conversation.
-        :type messages: list[dict[str, str]]
+        :type messages: List[Dict[str, str]]
         :param model: Model to use for chat completion, defaults to "gpt-3.5-turbo-16k"
         :type model: Literal[
-            "gpt-3.5-turbo-16k", "gpt-4-1106-preview", "mistral-small", "mixtral-8x7b-32768"
+            "gpt-3.5-turbo-16k", "gpt-4-1106-preview", "mistral-small",
+            "mixtral-8x7b-32768"
         ]
         :param stream: Whether to stream the response, defaults to False
         :type stream: bool
         :return: Chat completions
-        :rtype: CreateChatCompletionResponse | AsyncIterator[CreateChatCompletionResponseStream]
+        :rtype: Union[
+            CreateChatCompletionResponse,
+            AsyncIterator[CreateChatCompletionResponseStream]
+        ]
         """
         response = await self.client.request(
             method="POST",
             endpoint="/v1/openai/chat/completions",
             body=CreateChatCompletionRequest(
                 messages=messages,
                 model=model,
@@ -178,26 +197,29 @@
                 "Content-Type": CreateChatCompletionRequest.__content_type__,
             },
             accept=[
                 (CreateChatCompletionResponse.__content_type__, 1.0),
                 (CreateChatCompletionResponseStream.__content_type__, 1.0),
             ],
             stream=stream,
-            stream_type="lines"  # type: ignore
+            stream_type="lines",  # type: ignore
         )
 
         if stream:
+
             async def _stream():
                 async for chunk in response.content:
                     if chunk.strip() == "data: [DONE]":
                         break
 
                     if chunk.startswith("data:"):
                         json_data = chunk.replace("data: ", "").strip()
-                        yield CreateChatCompletionResponseStream.model_validate_json(json_data)
+                        yield CreateChatCompletionResponseStream.model_validate_json(
+                            json_data
+                        )
 
             return _stream()
         else:
             return CreateChatCompletionResponse.model_validate(response.content)
 
     async def list_chat_models(self) -> ListModelResponse:
         """
@@ -207,31 +229,28 @@
 
         :return: List of available chat models
         :rtype: ListModelResponse
         """
         response = await self.client.request(
             method="GET",
             endpoint="/v1/openai/chat/models",
-            accept=[(ListModelResponse.__content_type__, 1.0)]
+            accept=[(ListModelResponse.__content_type__, 1.0)],
         )
         return ListModelResponse.model_validate(response.content)
 
     async def get_headline_questions(
-        self,
-        queries: list[str] | None = None
-    ) -> dict[str, list[str]]:
+        self, queries: Optional[List[str]] = None
+    ) -> Dict[str, List[str]]:
         """
         Get headline questions for a given query.
 
         https://docs.asknews.app/en/reference#get-/v1/chat/questions
 
         :param queries: List of queries to get headline questions for
-        :type queries: list[str] | None
+        :type queries: Optional[List[str]]
         :return: Headline questions
-        :rtype: dict[str, list[str]]
+        :rtype: Dict[str, List[str]]
         """
         response = await self.client.request(
-            method="GET",
-            endpoint="/v1/chat/questions",
-            query={"queries": queries}
+            method="GET", endpoint="/v1/chat/questions", query={"queries": queries}
         )
         return response.content
```

## asknews_sdk/api/news.py

```diff
@@ -1,89 +1,109 @@
-from typing import Literal
+from typing import List, Literal, Optional
+from uuid import UUID
 
 from asknews_sdk.api.base import BaseAPI
-from asknews_sdk.dto.news import (
-    SearchResponse,
-    SourceReportResponse
-)
+from asknews_sdk.dto.news import Article, SearchResponse, SourceReportResponse
+
 
 class NewsAPI(BaseAPI):
     """
     News API
 
     https://docs.asknews.app/en/reference#tag--news
     """
+
+    def get_article(self, article_id: str | UUID):
+        response = self.client.request(
+            method="GET",
+            endpoint="/v1/news/{article_id}",
+            params={"article_id": article_id},
+        )
+        return Article.model_validate(response.content)
+
     def search_news(
         self,
         query: str,
         n_articles: int = 10,
-        start_timestamp: int | None = None,
-        end_timestamp: int | None = None,
+        start_timestamp: Optional[int] = None,
+        end_timestamp: Optional[int] = None,
         return_type: Literal["string", "dicts", "both"] = "dicts",
         historical: bool = False,
         method: Literal["nl", "kw"] = "nl",
         similarity_score_threshold: float = 0.5,
         offset: int = 0,
-        categories: list[
-            Literal[
-                "All",
-                "Business",
-                "Crime",
-                "Politics",
-                "Science",
-                "Sports",
-                "Technology",
-                "Military",
-                "Health",
-                "Entertainment"
+        categories: Optional[
+            List[
+                Literal[
+                    "All",
+                    "Business",
+                    "Crime",
+                    "Politics",
+                    "Science",
+                    "Sports",
+                    "Technology",
+                    "Military",
+                    "Health",
+                    "Entertainment",
+                    "Finance",
+                    "Culture",
+                    "Climate",
+                    "Environment",
+                    "World",
+                ]
             ]
-        ] = ["All"],
+        ] = None,
         doc_start_delimiter: str = "<doc>",
         doc_end_delimiter: str = "</doc>",
     ) -> SearchResponse:
         """
         Search for news articles given a query.
 
         https://docs.asknews.app/en/reference#get-/v1/news/search
 
-        :param query: Query string that can be any phrase, keyword, question, or paragraph.
+        :param query: Query string that can be any phrase, keyword, question, or
+            paragraph.
             If method='nl', then this will be used as a natural language query.
             If method='kw', then this will be used as a direct keyword query.
         :type query: str
         :param n_articles: Number of articles to return, defaults to 10
-        :type n_articles: int | None
+        :type n_articles: Optional[int]
         :param start_timestamp: Start timestamp to search from, defaults to None
-        :type start_timestamp: int | None
+        :type start_timestamp: Optional[int]
         :param end_timestamp: End timestamp to search to, defaults to None
-        :type end_timestamp: int | None
-        :param return_type: Type of return value. 'string' means that the return is prompt-optimized
-            and ready to be immediately injected into any prompt. 'dicts' means that the
-            return is a structured dictionary, containing more information such as full
-            article content, and additional metadata (like a classic news api). Can be
-            'string' or 'dicts', or 'both', defaults to "dicts".
+        :type end_timestamp: Optional[int]
+        :param return_type: Type of return value. 'string' means that the return is
+            prompt-optimized and ready to be immediately injected into any prompt.
+            'dicts' means that the return is a structured dictionary, containing
+            more information such as full article content, and additional metadata
+            (like a classic news api). Can be 'string' or 'dicts', or 'both', defaults
+            to "dicts".
         :type return_type: Literal["string", "dicts", "both"]
         :param historical: Search on archive of historical news. Defaults to False,
-            meaning that the search will only look through the most recent news (48 hours)
+            meaning that the search will only look through the most recent news
+            (48 hours)
         :type historical: bool
-        :param method: Method to use for searching. 'nl' means Natural Language, which is a string
-            that can be any phrase, keyword, question, or paragraph that will be used for semantic
-            search on the news. 'kw' means Keyword, which can also be any keyword(s), phrase, or
-            paragraph, however the search is a direct keyword search on the database.
+        :param method: Method to use for searching. 'nl' means Natural Language, which
+            is a string that can be any phrase, keyword, question, or paragraph that
+            will be used for semantic search on the news. 'kw' means Keyword, which can
+            also be any keyword(s), phrase, or paragraph, however the search is a direct
+            keyword search on the database.
         :type method: Literal["nl", "kw"]
         :param similarity_score_threshold: Similarity score threshold, defaults to 0.5
         :type similarity_score_threshold: float
         :param offset: Offset for pagination
         :type offset: int
         :param categories: Categories of news to filter on, defaults to ["All"]
-        :type categories: list[
+        :type categories: Optional[List[
             Literal[
                 "All", "Business", "Crime", "Politics", "Science", "Sports",
-                "Technology", "Military", "Health", "Entertainment"
+                "Technology", "Military", "Health", "Entertainment", "Finance",
+                "Culture", "Climate", "Environment", "World"
             ]
-        ]
+        ]]
         :param doc_start_delimiter: Document start delimiter, defaults to "<doc>"
         :type doc_start_delimiter: str
         :param doc_end_delimiter: Document end delimiter, defaults to "</doc>"
         :type doc_end_delimiter: str
         """
         response = self.client.request(
             method="GET",
@@ -93,42 +113,42 @@
                 "n_articles": n_articles,
                 "start_timestamp": start_timestamp,
                 "end_timestamp": end_timestamp,
                 "return_type": return_type,
                 "method": method,
                 "historical": historical,
                 "offset": offset,
-                "categories": categories,
+                "categories": categories if categories is not None else ["All"],
                 "similarity_score_threshold": similarity_score_threshold,
                 "doc_start_delimiter": doc_start_delimiter,
                 "doc_end_delimiter": doc_end_delimiter,
             },
-            accept=[(SearchResponse.__content_type__, 1.0)]
+            accept=[(SearchResponse.__content_type__, 1.0)],
         )
         return SearchResponse.model_validate(response.content)
 
     def get_sources_report(
         self,
         n_points: int = 100,
-        start_timestamp: int | None = None,
-        end_timestamp: int | None = None,
+        start_timestamp: Optional[int] = None,
+        end_timestamp: Optional[int] = None,
         metric: str = "countries_diversity",
         sampling: str = "1h",
     ) -> SourceReportResponse:
         """
         Get the sources report.
 
         https://docs.asknews.app/en/reference#get-/v1/sources
 
         :param n_points: The number of points.
         :type n_points: int
         :param start_timestamp: The start timestamp.
-        :type start_timestamp: int | None
+        :type start_timestamp: Optional[int]
         :param end_timestamp: The end timestamp.
-        :type end_timestamp: int | None
+        :type end_timestamp: Optional[int]
         :param metric: The metric.
         :type metric: str
         :param sampling: The sampling.
         :type sampling: str
         :return: The source report response.
         :rtype: SourceReportResponse
         """
@@ -138,93 +158,114 @@
             query={
                 "n_points": n_points,
                 "start_timestamp": start_timestamp,
                 "end_timestamp": end_timestamp,
                 "metric": metric,
                 "sampling": sampling,
             },
-            accept=[(SourceReportResponse.__content_type__, 1.0)]
+            accept=[(SourceReportResponse.__content_type__, 1.0)],
         )
         return SourceReportResponse.model_validate(response.content)
 
 
 class AsyncNewsAPI(BaseAPI):
     """
     News API
 
     https://docs.asknews.app/en/reference#tag--news
     """
+
+    async def get_article(self, article_id: str | UUID):
+        response = await self.client.request(
+            method="GET",
+            endpoint="/v1/news/{article_id}",
+            params={"article_id": article_id},
+        )
+        return Article.model_validate(response.content)
+
     async def search_news(
         self,
         query: str,
         n_articles: int = 10,
-        start_timestamp: int | None = None,
-        end_timestamp: int | None = None,
+        start_timestamp: Optional[int] = None,
+        end_timestamp: Optional[int] = None,
         return_type: Literal["string", "dicts", "both"] = "dicts",
         historical: bool = False,
         method: Literal["nl", "kw"] = "nl",
         similarity_score_threshold: float = 0.5,
         offset: int = 0,
-        categories: list[
-            Literal[
-                "All",
-                "Business",
-                "Crime",
-                "Politics",
-                "Science",
-                "Sports",
-                "Technology",
-                "Military",
-                "Health",
-                "Entertainment"
+        categories: Optional[
+            List[
+                Literal[
+                    "All",
+                    "Business",
+                    "Crime",
+                    "Politics",
+                    "Science",
+                    "Sports",
+                    "Technology",
+                    "Military",
+                    "Health",
+                    "Entertainment",
+                    "Finance",
+                    "Culture",
+                    "Climate",
+                    "Environment",
+                    "World",
+                ]
             ]
-        ] = ["All"],
+        ] = None,
         doc_start_delimiter: str = "<doc>",
         doc_end_delimiter: str = "</doc>",
     ) -> SearchResponse:
         """
         Search for news articles given a query.
 
         https://docs.asknews.app/en/reference#get-/v1/news/search
 
-        :param query: Query string that can be any phrase, keyword, question, or paragraph.
+        :param query: Query string that can be any phrase, keyword, question, or
+            paragraph.
             If method='nl', then this will be used as a natural language query.
             If method='kw', then this will be used as a direct keyword query.
         :type query: str
         :param n_articles: Number of articles to return, defaults to 10
-        :type n_articles: int | None
+        :type n_articles: Optional[int]
         :param start_timestamp: Start timestamp to search from, defaults to None
-        :type start_timestamp: int | None
+        :type start_timestamp: Optional[int]
         :param end_timestamp: End timestamp to search to, defaults to None
-        :type end_timestamp: int | None
-        :param return_type: Type of return value. 'string' means that the return is prompt-optimized
-            and ready to be immediately injected into any prompt. 'dicts' means that the
-            return is a structured dictionary, containing more information such as full
-            article content, and additional metadata (like a classic news api). Can be
-            'string' or 'dicts', or 'both', defaults to "dicts".
+        :type end_timestamp: Optional[int]
+        :param return_type: Type of return value. 'string' means that the return is
+            prompt-optimized and ready to be immediately injected into any prompt.
+            'dicts' means that the return is a structured dictionary, containing more
+            information such as full article content, and additional metadata (like a
+            classic news api). Can be 'string' or 'dicts', or 'both', defaults to
+            "dicts".
         :type return_type: Literal["string", "dicts", "both"]
         :param historical: Search on archive of historical news. Defaults to False,
-            meaning that the search will only look through the most recent news (48 hours)
+            meaning that the search will only look through the most recent news
+            (48 hours)
         :type historical: bool
-        :param method: Method to use for searching. 'nl' means Natural Language, which is a string
-            that can be any phrase, keyword, question, or paragraph that will be used for semantic
-            search on the news. 'kw' means Keyword, which can also be any keyword(s), phrase, or
-            paragraph, however the search is a direct keyword search on the database.
+        :param method: Method to use for searching. 'nl' means Natural Language, which
+            is a string that can be any phrase, keyword, question, or paragraph that
+            will be used for semantic search on the news. 'kw' means Keyword, which can
+            also be any keyword(s), phrase, or paragraph, however the search is a direct
+            keyword search on the database.
         :type method: Literal["nl", "kw"]
         :param similarity_score_threshold: Similarity score threshold, defaults to 0.5
         :type similarity_score_threshold: float
         :param offset: Offset for pagination
         :type offset: int
         :param categories: Categories of news to filter on, defaults to ["All"]
-        :type categories: list[
+        :type categories: Optional[List[
             Literal[
                 "All", "Business", "Crime", "Politics", "Science", "Sports",
-                "Technology", "Military", "Health", "Entertainment"
+                "Technology", "Military", "Health", "Entertainment", "Finance",
+                "Culture", "Climate", "Environment", "World"
             ]
-        ]
+        ]]
         :param doc_start_delimiter: Document start delimiter, defaults to "<doc>"
         :type doc_start_delimiter: str
         :param doc_end_delimiter: Document end delimiter, defaults to "</doc>"
         :type doc_end_delimiter: str
         """
         response = await self.client.request(
             method="GET",
@@ -234,42 +275,42 @@
                 "n_articles": n_articles,
                 "start_timestamp": start_timestamp,
                 "end_timestamp": end_timestamp,
                 "return_type": return_type,
                 "method": method,
                 "historical": historical,
                 "offset": offset,
-                "categories": categories,
+                "categories": categories if categories is not None else ["All"],
                 "similarity_score_threshold": similarity_score_threshold,
                 "doc_start_delimiter": doc_start_delimiter,
                 "doc_end_delimiter": doc_end_delimiter,
             },
-            accept=[(SearchResponse.__content_type__, 1.0)]
+            accept=[(SearchResponse.__content_type__, 1.0)],
         )
         return SearchResponse.model_validate(response.content)
 
     async def get_sources_report(
         self,
         n_points: int = 100,
-        start_timestamp: int | None = None,
-        end_timestamp: int | None = None,
+        start_timestamp: Optional[int] = None,
+        end_timestamp: Optional[int] = None,
         metric: str = "countries_diversity",
         sampling: str = "1h",
     ) -> SourceReportResponse:
         """
         Get the sources report.
 
         https://docs.asknews.app/en/reference#get-/v1/sources
 
         :param n_points: The number of points.
         :type n_points: int
         :param start_timestamp: The start timestamp.
-        :type start_timestamp: int | None
+        :type start_timestamp: Optional[int]
         :param end_timestamp: The end timestamp.
-        :type end_timestamp: int | None
+        :type end_timestamp: Optional[int]
         :param metric: The metric.
         :type metric: str
         :param sampling: The sampling.
         :type sampling: str
         :return: The source report response.
         :rtype: SourceReportResponse
         """
@@ -278,10 +319,10 @@
             query={
                 "n_points": n_points,
                 "start_timestamp": start_timestamp,
                 "end_timestamp": end_timestamp,
                 "metric": metric,
                 "sampling": sampling,
             },
-            accept=[(SourceReportResponse.__content_type__, 1.0)]
+            accept=[(SourceReportResponse.__content_type__, 1.0)],
         )
         return SourceReportResponse.model_validate(response.content)
```

## asknews_sdk/api/stories.py

```diff
@@ -1,83 +1,87 @@
-from asknews_sdk.api.base import BaseAPI
-from asknews_sdk.dto.stories import (
-    StoriesResponse,
-    StoryResponse
-)
-from typing import Literal
+from typing import List, Literal, Optional, Union
 from uuid import UUID
 
+from asknews_sdk.api.base import BaseAPI
+from asknews_sdk.dto.stories import StoriesResponse, StoryResponse
+
+
 class StoriesAPI(BaseAPI):
     """
     Stories API
 
     https://docs.asknews.app/en/reference#tag--stories
     """
+
     def search_stories(
         self,
-        query: str | None = None,
-        categories: list[
+        query: Optional[str] = None,
+        categories: Optional[
+            List[
+                Literal[
+                    "Politics",
+                    "Economy",
+                    "Finance",
+                    "Science",
+                    "Technology",
+                    "Sports",
+                    "Climate",
+                    "Environment",
+                    "Culture",
+                    "Entertainment",
+                    "Business",
+                    "Health",
+                    "International",
+                ]
+            ]
+        ] = None,
+        uuids: Optional[List[UUID]] = None,
+        start_timestamp: Optional[int] = None,
+        end_timestamp: Optional[int] = None,
+        sort_by: Optional[
+            Literal["published", "coverage", "sentiment", "confidence", "relevance"]
+        ] = None,
+        sort_type: Optional[Literal["asc", "desc"]] = None,
+        continent: Optional[
             Literal[
-                "Politics",
-                "Economy",
-                "Finance",
-                "Science",
-                "Technology",
-                "Sports",
-                "Climate",
-                "Environment",
-                "Culture",
-                "Entertainment",
-                "Business",
-                "Health",
-                "International"
+                "Africa",
+                "Asia",
+                "Europe",
+                "Middle East",
+                "North America",
+                "South America",
+                "Oceania",
             ]
-        ] = [],
-        uuids: list[UUID] = [],
-        start_timestamp: int | None = None,
-        end_timestamp: int | None = None,
-        sort_by: Literal[
-            "published", "coverage", "sentiment", "confidence", "relevance"
-        ] | None = None,
-        sort_type: Literal["asc", "desc"] | None = None,
-        continent: Literal[
-            "Africa",
-            "Asia",
-            "Europe",
-            "Middle East",
-            "North America",
-            "South America",
-            "Oceania",
-        ] | None = None,
-        offset: int | str | None = None,
+        ] = None,
+        offset: Optional[Union[int, str]] = None,
         limit: int = 50,
         expand_updates: bool = False,
         max_updates: int = 11,
         max_articles: int = 5,
         reddit: int = 0,
         method: Literal["nl", "kw", "both"] = "kw",
-        obj_type: list[Literal["story", "story_update"]] = ["story"]
+        obj_type: Optional[List[Literal["story", "story_update"]]] = None,
     ) -> StoriesResponse:
         """
         Get the news stories.
 
         https://docs.asknews.app/en/reference#get-/v1/stories
 
         :param query: The query.
-        :type query: str | None
+        :type query: Optional[str]
         :param categories: The categories.
-        :type categories: str | None
+        :type categories: Optional[str]
         :param start_timestamp: The start timestamp.
-        :type start_timestamp: int | None
+        :type start_timestamp: Optional[int]
         :param end_timestamp: The end timestamp.
-        :type end_timestamp: int | None
+        :type end_timestamp: Optional[int]
         :param sort_by_time: Whether to sort by time.
         :type sort_by_time: bool
         :param continent: The continent to filter by.
-        :type continent: str | None
+        :type continent: Optional[str]
         :param offset: The offset.
         :type offset: int
         :param limit: The limit.
         :type limit: int
         :param expand_updates: Whether to expand updates.
         :type expand_updates: bool
         :param max_updates: The max updates per story.
@@ -85,15 +89,15 @@
         :param max_articles: The max articles per update.
         :type max_articles: int
         :param reddit: Amount of reddit threads to include per update.
         :type reddit: int
         :param method: The method to use for searching.
         :type method: str
         :param obj_type: The object type to filter on.
-        :type obj_type: list[str]
+        :type obj_type: List[str]
         :return: The stories response.
         :rtype: StoriesResponse
         """
         response = self.client.request(
             method="GET",
             endpoint="/v1/stories",
             query={
@@ -102,30 +106,30 @@
                 "start_timestamp": start_timestamp,
                 "end_timestamp": end_timestamp,
                 "offset": offset,
                 "method": method,
                 "sort_by": sort_by,
                 "sort_type": sort_type,
                 "continent": continent,
-                "obj_type": obj_type,
+                "obj_type": obj_type if obj_type is not None else ["story"],
                 "reddit": reddit,
                 "limit": limit,
                 "expand_updates": expand_updates,
                 "max_updates": max_updates,
                 "max_articles": max_articles,
-                "uuids": uuids
+                "uuids": uuids,
             },
-            accept=[(StoriesResponse.__content_type__, 1.0)]
+            accept=[(StoriesResponse.__content_type__, 1.0)],
         )
 
         return StoriesResponse.model_validate(response.content)
 
     def get_story(
         self,
-        story_id: UUID | str,
+        story_id: Union[UUID, str],
         expand_updates: bool = True,
         max_updates: int = 11,
         max_articles: int = 5,
         reddit: int = 0,
     ) -> StoryResponse:
         """
         Get a single news story given the ID.
@@ -148,92 +152,95 @@
         response = self.client.request(
             method="GET",
             endpoint="/v1/stories/{story_id}",
             query={
                 "expand_updates": expand_updates,
                 "max_updates": max_updates,
                 "max_articles": max_articles,
-                "reddit": reddit
+                "reddit": reddit,
             },
             params={"story_id": story_id},
-            accept=[(StoryResponse.__content_type__, 1.0)]
+            accept=[(StoryResponse.__content_type__, 1.0)],
         )
         return StoryResponse.model_validate(response.content)
 
 
 class AsyncStoriesAPI(BaseAPI):
     """
     Stories API
 
     https://docs.asknews.app/en/reference#tag--stories
     """
+
     async def search_stories(
         self,
-        query: str | None = None,
-        categories: list[
+        query: Optional[str] = None,
+        categories: Optional[
+            List[
+                Literal[
+                    "Politics",
+                    "Economy",
+                    "Finance",
+                    "Science",
+                    "Technology",
+                    "Sports",
+                    "Climate",
+                    "Environment",
+                    "Culture",
+                    "Entertainment",
+                    "Business",
+                    "Health",
+                    "International",
+                ]
+            ]
+        ] = None,
+        uuids: Optional[List[UUID]] = None,
+        start_timestamp: Optional[int] = None,
+        end_timestamp: Optional[int] = None,
+        sort_by: Optional[
+            Literal["published", "coverage", "sentiment", "relevance", "confidence"]
+        ] = None,
+        sort_type: Optional[Literal["asc", "desc"]] = None,
+        continent: Optional[
             Literal[
-                "Politics",
-                "Economy",
-                "Finance",
-                "Science",
-                "Technology",
-                "Sports",
-                "Climate",
-                "Environment",
-                "Culture",
-                "Entertainment",
-                "Business",
-                "Health",
-                "International"
+                "Africa",
+                "Asia",
+                "Europe",
+                "Middle East",
+                "North America",
+                "South America",
+                "Oceania",
             ]
-        ] = [],
-        uuids: list[UUID] = [],
-        start_timestamp: int | None = None,
-        end_timestamp: int | None = None,
-        sort_by: Literal[
-            "published", "coverage", "sentiment", "relevance", "confidence"
-        ] | None = None,
-        sort_type: Literal["asc", "desc"] | None = None,
-        continent: Literal[
-            "Africa",
-            "Asia",
-            "Europe",
-            "Middle East",
-            "North America",
-            "South America",
-            "Oceania",
-        ] | None = None,
-        offset: int | str | None = None,
+        ] = None,
+        offset: Optional[Union[int, str]] = None,
         limit: int = 50,
         expand_updates: bool = False,
         max_updates: int = 11,
         max_articles: int = 5,
         reddit: int = 0,
         method: Literal["nl", "kw", "both"] = "kw",
-        obj_type: list[
-            Literal["story", "story_update"]
-        ] = ["story"]
+        obj_type: Optional[List[Literal["story", "story_update"]]] = None,
     ) -> StoriesResponse:
         """
         Get the news stories.
 
         https://docs.asknews.app/en/reference#get-/v1/stories
 
         :param query: The query.
-        :type query: str | None
+        :type query: Optional[str]
         :param categories: The categories.
-        :type categories: str | None
+        :type categories: Optional[str]
         :param start_timestamp: The start timestamp.
-        :type start_timestamp: int | None
+        :type start_timestamp: Optonal[int]
         :param end_timestamp: The end timestamp.
-        :type end_timestamp: int | None
+        :type end_timestamp: Optonal[int]
         :param sort_by_time: Whether to sort by time.
         :type sort_by_time: bool
         :param continent: The continent to filter by.
-        :type continent: str | None
+        :type continent: Optional[str]
         :param offset: The offset.
         :type offset: int
         :param limit: The limit.
         :type limit: int
         :param expand_updates: Whether to expand updates.
         :type expand_updates: bool
         :param max_updates: The max updates per story.
@@ -241,15 +248,15 @@
         :param max_articles: The max articles per update.
         :type max_articles: int
         :param reddit: Amount of reddit threads to include per update.
         :type reddit: int
         :param method: The method to use for searching.
         :type method: str
         :param obj_type: The object type to filter on.
-        :type obj_type: list[str]
+        :type obj_type: List[str]
         :return: The stories response.
         :rtype: StoriesResponse
         """
         response = await self.client.request(
             method="GET",
             endpoint="/v1/stories",
             query={
@@ -258,30 +265,30 @@
                 "start_timestamp": start_timestamp,
                 "end_timestamp": end_timestamp,
                 "offset": offset,
                 "method": method,
                 "sort_by": sort_by,
                 "sort_type": sort_type,
                 "continent": continent,
-                "obj_type": obj_type,
+                "obj_type": obj_type if obj_type is not None else ["story"],
                 "reddit": reddit,
                 "limit": limit,
                 "expand_updates": expand_updates,
                 "max_updates": max_updates,
                 "max_articles": max_articles,
-                "uuids": uuids
+                "uuids": uuids,
             },
-            accept=[(StoriesResponse.__content_type__, 1.0)]
+            accept=[(StoriesResponse.__content_type__, 1.0)],
         )
 
         return StoriesResponse.model_validate(response.content)
 
     async def get_story(
         self,
-        story_id: UUID | str,
+        story_id: Union[UUID, str],
         expand_updates: bool = True,
         max_updates: int = 11,
         max_articles: int = 5,
         reddit: int = 0,
     ) -> StoryResponse:
         """
         Get a single news story given the ID.
@@ -304,13 +311,13 @@
         response = await self.client.request(
             method="GET",
             endpoint="/v1/stories/{story_id}",
             query={
                 "expand_updates": expand_updates,
                 "max_updates": max_updates,
                 "max_articles": max_articles,
-                "reddit": reddit
+                "reddit": reddit,
             },
             params={"story_id": story_id},
-            accept=[(StoryResponse.__content_type__, 1.0)]
+            accept=[(StoryResponse.__content_type__, 1.0)],
         )
         return StoryResponse.model_validate(response.content)
```

## asknews_sdk/client.py

```diff
@@ -1,89 +1,100 @@
 from __future__ import annotations
 
 import asyncio
 import threading
 from enum import Enum
-from typing import Any, Callable
-from httpx import Client, AsyncClient, HTTPStatusError
-from authlib.integrations.httpx_client import OAuth2Client, AsyncOAuth2Client
+from typing import Any, Callable, Dict, List, Optional, Set, Union
+
 from asgiref.typing import ASGIApplication
+from authlib.integrations.httpx_client import AsyncOAuth2Client, OAuth2Client
+from httpx import AsyncClient, Client, HTTPStatusError
 
-from asknews_sdk.version import __version__
 from asknews_sdk.errors import raise_from_json
 from asknews_sdk.security import (
-    OAuthToken,
+    AsyncTokenLoadHook,
+    AsyncTokenSaveHook,
     InjectToken,
-    TokenSaveHook,
+    OAuthToken,
     TokenLoadHook,
-    AsyncTokenSaveHook,
-    AsyncTokenLoadHook,
+    TokenSaveHook,
 )
 from asknews_sdk.utils import (
-    serialize,
-    deserialize,
     build_accept_header,
     build_url,
-    determine_content_type
+    deserialize,
+    determine_content_type,
+    serialize,
 )
+from asknews_sdk.version import __version__
 
 USER_AGENT = f"asknews-sdk-python/{__version__}"
 
+
 class StreamType(str, Enum):
     bytes = "bytes"
     lines = "lines"
     raw = "raw"
 
 
 class APIRequest:
     """
     API Request object used by the APIClient.
     """
+
     def __init__(
         self,
         base_url: str,
         method: str,
         endpoint: str,
-        body: Any | None = None,
-        query: dict | None = None,
-        headers: dict | None = None,
-        params: dict | None = None,
-        accept: list[tuple[str, float]] | None = None,
+        body: Optional[Any] = None,
+        query: Optional[Dict] = None,
+        headers: Optional[Dict] = None,
+        params: Optional[Dict] = None,
+        accept: Optional[List[tuple[str, float]]] = None,
     ) -> None:
         self.base_url = base_url
         self.method = method
         self.endpoint = endpoint
         self.query = query
         self.params = params
         self.accept = accept
         self.url = build_url(
             base_url=self.base_url,
             endpoint=self.endpoint,
             query=self.query,
-            params=self.params
+            params=self.params,
         )
         self.headers = headers or {}
-        self.content_type = self.headers.pop("Content-Type", determine_content_type(body))
+        self.content_type = self.headers.pop(
+            "Content-Type", determine_content_type(body)
+        )
         self.body = serialize(body) if body and not isinstance(body, bytes) else None
         self.accept = accept or [
-            (self.content_type if "json" in self.content_type else "application/json", 1.0)
+            (
+                self.content_type
+                if "json" in self.content_type
+                else "application/json",
+                1.0,
+            )
         ]
         self.headers["Content-Type"] = self.content_type
         self.headers["Accept"] = build_accept_header(self.accept)
 
 
 class APIResponse:
     """
     API Response object returned by the APIClient.
     """
+
     def __init__(
         self,
         request: APIRequest,
         status_code: int,
-        headers: dict,
+        headers: Dict,
         body: bytes,
         stream: bool = False,
     ) -> None:
         self.request = request
         self.status_code = status_code
         self.headers = headers
         self.body = body
@@ -103,25 +114,25 @@
 
 
 class BaseAPIClient:
     def __init__(
         self,
         client_id: str,
         client_secret: str,
-        scopes: set[str] | None,
+        scopes: Optional[Set[str]],
         base_url: str,
         token_url: str,
         verify_ssl: bool = True,
         retries: int = 3,
-        timeout: float | None = None,
+        timeout: Optional[float] = None,
         follow_redirects: bool = True,
         *,
-        _mock_server: ASGIApplication | Callable[..., Any] | None = None,
-        _token_save_hook: TokenSaveHook | AsyncTokenSaveHook | None = None,
-        _token_load_hook: TokenLoadHook | AsyncTokenLoadHook | None = None,
+        _mock_server: Optional[Union[ASGIApplication, Callable[..., Any]]] = None,
+        _token_save_hook: Optional[Union[TokenSaveHook, AsyncTokenSaveHook]] = None,
+        _token_load_hook: Optional[Union[TokenLoadHook, AsyncTokenLoadHook]] = None,
     ) -> None:
         self.client_id = client_id
         self.client_secret = client_secret
         self.scopes = {"offline", "openid", *(scopes or set())}
         self.base_url = base_url
         self.token_url = token_url
         self.verify_ssl = verify_ssl
@@ -132,26 +143,27 @@
         self._mock_server = _mock_server
         self._token_save_hook = _token_save_hook
         self._token_load_hook = _token_load_hook
 
         self._token = OAuthToken()
 
     def _get_oauth_client(
-        self,
-        client: OAuth2Client | AsyncOAuth2Client
-    ) -> OAuth2Client | AsyncOAuth2Client:
+        self, client: Union[OAuth2Client, AsyncOAuth2Client]
+    ) -> Union[OAuth2Client, AsyncOAuth2Client]:
         return client(
             client_id=self.client_id,
             client_secret=self.client_secret,
             scope=" ".join(self.scopes) if self.scopes else None,
             token_endpoint_auth_method="client_secret_basic",
             token_type="Bearer",
         )
 
-    def _get_http_client(self, client: Client | AsyncClient) -> Client | AsyncClient:
+    def _get_http_client(
+        self, client: Union[Client, AsyncClient]
+    ) -> Union[Client, AsyncClient]:
         return client(
             base_url=self.base_url,
             verify=self.verify_ssl,
             timeout=self.timeout,
             auth=InjectToken(self._token),
             follow_redirects=self.follow_redirects,
             headers={"User-Agent": USER_AGENT},
@@ -169,43 +181,44 @@
     Sync HTTP API Client
 
     :param client_id: Client ID
     :type client_id: str
     :param client_secret: Client secret
     :type client_secret: str
     :param scopes: OAuth scopes
-    :type scopes: set[str]
+    :type scopes: Set[str]
     :param base_url: Base URL
     :type base_url: str
     :param token_url: Token URL
     :type token_url: str
     :param verify_ssl: Verify SSL certificate
     :type verify_ssl: bool
     :param retries: Default number of retries
     :type retries: int
     :param timeout: Request timeout
     :type timeout: Optional[float]
     :param follow_redirects: Follow redirects
     :type follow_redirects: bool
     """
+
     def __init__(
         self,
         client_id: str,
         client_secret: str,
-        scopes: set[str] | None,
+        scopes: Optional[Set[str]],
         base_url: str,
         token_url: str,
         verify_ssl: bool = True,
         retries: int = 3,
-        timeout: float | None = None,
+        timeout: Optional[float] = None,
         follow_redirects: bool = True,
         *,
-        _mock_server: Callable[..., Any] | None = None,
-        _token_save_hook: TokenSaveHook | None = None,
-        _token_load_hook: TokenLoadHook | None = None,
+        _mock_server: Optional[Callable[..., Any]] = None,
+        _token_save_hook: Optional[TokenSaveHook] = None,
+        _token_load_hook: Optional[TokenLoadHook] = None,
     ) -> None:
         super().__init__(
             client_id=client_id,
             client_secret=client_secret,
             scopes=scopes,
             base_url=base_url,
             token_url=token_url,
@@ -265,39 +278,39 @@
             if self._token.is_expired:
                 self._get_token()
 
     def request(
         self,
         method: str,
         endpoint: str,
-        body: Any | None = None,
-        query: dict | None = None,
-        headers: dict | None = None,
-        params: dict | None = None,
-        accept: list[tuple[str, float]] | None = None,
+        body: Optional[Any] = None,
+        query: Optional[Dict] = None,
+        headers: Optional[Dict] = None,
+        params: Optional[Dict] = None,
+        accept: Optional[List[tuple[str, float]]] = None,
         stream: bool = False,
         stream_type: StreamType = StreamType.bytes,
     ) -> APIResponse:
         """
         Send an HTTP request.
 
         :param method: HTTP method
         :type method: str
         :param endpoint: API endpoint
         :type endpoint: str
         :param body: Request body
-        :type body: Any | None
+        :type body: Optional[Any]
         :param query: Query parameters
-        :type query: dict | None
+        :type query: Optional[Dict]
         :param headers: Request headers
-        :type headers: dict | None
+        :type headers: Optional[Dict]
         :param params: Path parameters
-        :type params: dict | None
+        :type params: Optional[Dict]
         :param accept: Accept header
-        :type accept: list[tuple[str, float]] | None
+        :type accept: Optional[List[tuple[str, float]]]
         :param stream: Stream response content
         :type stream: bool
         :param stream_type: Stream type
         :type stream_type: StreamType
         :return: APIResponse object
         :rtype: APIResponse
         """
@@ -321,26 +334,23 @@
             url=request.url,
             content=request.body,
             headers=request.headers,
         )
         try:
             response.raise_for_status()
         except HTTPStatusError as e:
-            raise_from_json(
-                e.response.json()
-            )
+            raise_from_json(e.response.json())
 
         if stream:
-            match stream_type:
-                case StreamType.bytes:
-                    response_body = response.iter_bytes()
-                case StreamType.lines:
-                    response_body = response.iter_lines()
-                case StreamType.raw:
-                    response_body = response.iter_raw()
+            if stream_type == StreamType.bytes:
+                response_body = response.aiter_bytes()
+            elif stream_type == StreamType.lines:
+                response_body = response.aiter_lines()
+            elif stream_type == StreamType.raw:
+                response_body = response.aiter_raw()
         else:
             response_body = response.content
 
         return APIResponse(
             request=request,
             status_code=response.status_code,
             headers=dict(response.headers.items()),
@@ -354,43 +364,44 @@
     Base Async HTTP API Client
 
     :param client_id: Client ID
     :type client_id: str
     :param client_secret: Client secret
     :type client_secret: str
     :param scopes: OAuth scopes
-    :type scopes: set[str]
+    :type scopes: Set[str]
     :param base_url: Base URL
     :type base_url: str
     :param token_url: Token URL
     :type token_url: str
     :param verify_ssl: Verify SSL certificate
     :type verify_ssl: bool
     :param retries: Default number of retries
     :type retries: int
     :param timeout: Request timeout
     :type timeout: Optional[float]
     :param follow_redirects: Follow redirects
     :type follow_redirects: bool
     """
+
     def __init__(
         self,
         client_id: str,
         client_secret: str,
-        scopes: set[str] | None,
+        scopes: Optional[Set[str]],
         base_url: str,
         token_url: str,
         verify_ssl: bool = True,
         retries: int = 3,
-        timeout: float | None = None,
+        timeout: Optional[float] = None,
         follow_redirects: bool = True,
         *,
-        _mock_server: ASGIApplication | None = None,
-        _token_save_hook: AsyncTokenSaveHook | None = None,
-        _token_load_hook: AsyncTokenLoadHook | None = None,
+        _mock_server: Optional[ASGIApplication] = None,
+        _token_save_hook: Optional[AsyncTokenSaveHook] = None,
+        _token_load_hook: Optional[AsyncTokenLoadHook] = None,
     ) -> None:
         super().__init__(
             client_id=client_id,
             client_secret=client_secret,
             scopes=scopes,
             base_url=base_url,
             token_url=token_url,
@@ -450,39 +461,39 @@
             if self._token.is_expired:
                 await self._get_token()
 
     async def request(
         self,
         method: str,
         endpoint: str,
-        body: Any | None = None,
-        query: dict | None = None,
-        headers: dict | None = None,
-        params: dict | None = None,
-        accept: list[tuple[str, float]] | None = None,
+        body: Optional[Any] = None,
+        query: Optional[Dict] = None,
+        headers: Optional[Dict] = None,
+        params: Optional[Dict] = None,
+        accept: Optional[List[tuple[str, float]]] = None,
         stream: bool = False,
         stream_type: StreamType = StreamType.bytes,
     ) -> APIResponse:
         """
         Send an HTTP request.
 
         :param method: HTTP method
         :type method: str
         :param endpoint: API endpoint
         :type endpoint: str
         :param body: Request body
-        :type body: Any | None
+        :type body: Optional[Any]
         :param query: Query parameters
-        :type query: dict | None
+        :type query: Optional[Dict]
         :param headers: Request headers
-        :type headers: dict | None
+        :type headers: Optional[Dict]
         :param params: Path parameters
-        :type params: dict | None
+        :type params: Optional[Dict]
         :param accept: Accept header
-        :type accept: list[tuple[str, float]] | None
+        :type accept: Optional[List[tuple[str, float]]]
         :param stream: Stream response content
         :type stream: bool
         :param stream_type: Stream type
         :type stream_type: StreamType
         :return: APIResponse object
         :rtype: APIResponse
         """
@@ -506,26 +517,23 @@
             url=request.url,
             content=request.body,
             headers=request.headers,
         )
         try:
             response.raise_for_status()
         except HTTPStatusError as e:
-            raise_from_json(
-                e.response.json()
-            )
+            raise_from_json(e.response.json())
 
         if stream:
-            match stream_type:
-                case StreamType.bytes:
-                    response_body = response.aiter_bytes()
-                case StreamType.lines:
-                    response_body = response.aiter_lines()
-                case StreamType.raw:
-                    response_body = response.aiter_raw()
+            if stream_type == StreamType.bytes:
+                response_body = response.aiter_bytes()
+            elif stream_type == StreamType.lines:
+                response_body = response.aiter_lines()
+            elif stream_type == StreamType.raw:
+                response_body = response.aiter_raw()
         else:
             response_body = response.content
 
         return APIResponse(
             request=request,
             status_code=response.status_code,
             headers=dict(response.headers.items()),
```

## asknews_sdk/dto/__init__.py

```diff
@@ -1,30 +1,22 @@
-from asknews_sdk.dto.error import APIErrorModel, ValidationError, HTTPValidationError
+from asknews_sdk.dto.error import APIErrorModel, HTTPValidationError, ValidationError
+from asknews_sdk.dto.news import SearchResponse, SearchResponseDictItem
 from asknews_sdk.dto.sentiment import (
     FinanceResponse,
     FinanceResponseTimeSeries,
-    FinanceResponseTimeSeriesData
-)
-from asknews_sdk.dto.stories import (
-    StoriesResponse,
-    StoryResponse,
-    StoryResponseUpdate
-)
-from asknews_sdk.dto.news import (
-    SearchResponse,
-    SearchResponseDictItem
+    FinanceResponseTimeSeriesData,
 )
+from asknews_sdk.dto.stories import StoriesResponse, StoryResponse, StoryResponseUpdate
 
 __all__ = (
     "APIErrorModel",
     "ValidationError",
     "HTTPValidationError",
     "FinanceResponse",
     "FinanceResponseTimeSeries",
     "FinanceResponseTimeSeriesData",
     "StoriesResponse",
     "StoryResponse",
     "StoryResponseUpdate",
     "SearchResponse",
     "SearchResponseDictItem",
-    "SearchResponseDictItemEntites"
 )
```

## asknews_sdk/dto/base.py

```diff
@@ -1,72 +1,72 @@
-from typing import ClassVar
-from pydantic import BaseModel
-from datetime import datetime
-from pydantic import AnyUrl
-from typing import Annotated
-from pydantic import Field
+from typing import ClassVar, List, Optional, Union
 from uuid import UUID
 
+from pydantic import AnyUrl, AwareDatetime, BaseModel, Field
+from typing_extensions import Annotated
+
 
 class BaseSchema(BaseModel):
     __content_type__: ClassVar[str] = "application/json"
 
 
 class RedditEntities(BaseModel):
-    DATE: list[str] = []
-    EVENT: list[str] = []
-    GPE: list[str] = []
-    ORG: list[str] = []
-    PERSON: list[str] = []
-    NORP: list[str] = []
-    CARDINAL: list[str] = []
+    DATE: Annotated[Optional[List[str]], Field([], title="Date")]
+    EVENT: Annotated[Optional[List[str]], Field([], title="Event")]
+    GPE: Annotated[Optional[List[str]], Field([], title="Gpe")]
+    ORG: Annotated[Optional[List[str]], Field([], title="Org")]
+    PERSON: Annotated[Optional[List[str]], Field([], title="Person")]
+    NORP: Annotated[Optional[List[str]], Field([], title="Norp")]
+    CARDINAL: Annotated[Optional[List[str]], Field([], title="Cardinal")]
 
 
 class Entities(BaseModel):
-    Person: list[str] = []
-    Organization: list[str] = []
-    Location: list[str] = []
-    Nationality: list[str] = []
-    Event: list[str] = []
-    Money: list[str] = []
-    Law: list[str] = []
-    Quantity: list[str] = []
-    Time: list[str] = []
-    Sports: list[str] = []
-    Politics: list[str] = []
-    Title: list[str] = []
-    Number: list[str] = []
-    Arms: list[str] = []
-    Product: list[str] = []
-    Media: list[str] = []
-    Transportation: list[str] = []
-    Religion: list[str] = []
-    Technology: list[str] = []
-    Space: list[str] = []
-    Medicine: list[str] = []
-    Language: list[str] = []
-    Science: list[str] = []
+    Person: Annotated[Optional[List[str]], Field([], title="Person")]
+    Organization: Annotated[Optional[List[str]], Field([], title="Organization")]
+    Location: Annotated[Optional[List[str]], Field([], title="Location")]
+    Nationality: Annotated[Optional[List[str]], Field([], title="Nationality")]
+    Date: Annotated[Optional[List[str]], Field([], title="Date")]
+    Event: Annotated[Optional[List[str]], Field([], title="Event")]
+    Money: Annotated[Optional[List[str]], Field([], title="Money")]
+    Law: Annotated[Optional[List[str]], Field([], title="Law")]
+    Quantity: Annotated[Optional[List[str]], Field([], title="Quantity")]
+    Time: Annotated[Optional[List[str]], Field([], title="Time")]
+    Sports: Annotated[Optional[List[str]], Field([], title="Sports")]
+    Politics: Annotated[Optional[List[str]], Field([], title="Politics")]
+    Title: Annotated[Optional[List[str]], Field([], title="Title")]
+    Number: Annotated[Optional[List[str]], Field([], title="Number")]
+    Arms: Annotated[Optional[List[str]], Field([], title="Arms")]
+    Product: Annotated[Optional[List[str]], Field([], title="Product")]
+    Media: Annotated[Optional[List[str]], Field([], title="Media")]
+    Transportation: Annotated[Optional[List[str]], Field([], title="Transportation")]
+    Religion: Annotated[Optional[List[str]], Field([], title="Religion")]
+    Technology: Annotated[Optional[List[str]], Field([], title="Technology")]
+    Space: Annotated[Optional[List[str]], Field([], title="Space")]
+    Medicine: Annotated[Optional[List[str]], Field([], title="Medicine")]
+    Language: Annotated[Optional[List[str]], Field([], title="Language")]
+    Science: Annotated[Optional[List[str]], Field([], title="Science")]
+
 
 class Article(BaseModel):
-    article_id: Annotated[UUID, Field(title='Article Id')]
-    article_url: Annotated[AnyUrl, Field(title='Article Url')]
-    classification: Annotated[list[str] | str, Field(title='Classification')]
-    country: Annotated[str, Field(title='Country')]
-    source_id: Annotated[str, Field(title='Source Id')]
-    page_rank: Annotated[int, Field(title='Page Rank')]
-    domain_url: Annotated[str, Field(title='Domain Url')]
-    eng_title: Annotated[str, Field(title='English Title')]
-    entities: Annotated[Entities, Field(title='Entities')]
-    image_url: Annotated[str | None, Field(title='Image Url')] = None
-    keywords: Annotated[list[str], Field(title='Keywords')]
-    language: Annotated[str, Field(title='Language')]
-    pub_date: Annotated[datetime, Field(title='Pubdate')]
-    summary: Annotated[str, Field(title='Summary')]
-    title: Annotated[str, Field(title='Title')]
-    sentiment: Annotated[int, Field(title='Sentiment')]
-    medoid_distance: Annotated[float | None, Field(title='Medoid Distance')] = None
-    markdown_citation: Annotated[str, Field(title='Markdown Citation')] = ""
+    article_url: Annotated[AnyUrl, Field(title="Article Url")]
+    article_id: Annotated[UUID, Field(title="Article Id")]
+    classification: Annotated[Union[List[str], str], Field(title="Classification")]
+    country: Annotated[str, Field(title="Country")]
+    source_id: Annotated[str, Field(title="Source Id")]
+    page_rank: Annotated[int, Field(title="Page Rank")]
+    domain_url: Annotated[str, Field(title="Domain Url")]
+    eng_title: Annotated[str, Field(title="Eng Title")]
+    entities: Annotated[Entities, Field(title="Entities")]
+    image_url: Annotated[Optional[str], Field(None, title="Image Url")]
+    keywords: Annotated[List[str], Field(title="Keywords")]
+    language: Annotated[str, Field(title="Language")]
+    pub_date: Annotated[AwareDatetime, Field(title="Pub Date")]
+    summary: Annotated[str, Field(title="Summary")]
+    title: Annotated[str, Field(title="Title")]
+    sentiment: Annotated[int, Field(title="Sentiment")]
+    medoid_distance: Annotated[Optional[float], Field(title="Medoid Distance")] = None
+    markdown_citation: Annotated[Optional[str], Field("", title="Markdown Citation")]
 
 
 class PingResponse(BaseSchema):
-    app: Annotated[str, Field(title='App')]
-    version: Annotated[str, Field(title='Version')]
+    app: Annotated[str, Field(title="App")]
+    version: Annotated[str, Field(title="Version")]
```

## asknews_sdk/dto/chat.py

```diff
@@ -1,98 +1,117 @@
 from __future__ import annotations
 
 from datetime import datetime, timezone
-from typing import Annotated, Any, Literal
-from pydantic import BaseModel, Field, ConfigDict
+from typing import Any, Dict, List, Literal, Optional, Union
+
+from pydantic import BaseModel, ConfigDict, Field
+from typing_extensions import Annotated
 
 from asknews_sdk.dto.base import BaseSchema
 
 
 class CreateChatCompletionRequestMessage(BaseModel):
-    role: Annotated[str, Field(title='Role')]
-    content: Annotated[str, Field(title='Content')]
-    name: Annotated[str | None, Field(None, title='Name')]
-    function_call: Annotated[dict[str, Any] | None, Field(None, title='Function Call')]
+    role: Annotated[str, Field(title="Role")]
+    content: Annotated[str, Field(title="Content")]
+    name: Annotated[Optional[str], Field(None, title="Name")]
+    function_call: Annotated[
+        Optional[Dict[str, Any]], Field(None, title="Function Call")
+    ]
 
 
 class CreateChatCompletionResponseChoice(BaseModel):
-    index: Annotated[int, Field(title='Index')]
+    index: Annotated[int, Field(title="Index")]
     message: CreateChatCompletionRequestMessage
-    finish_reason: Annotated[str | None, Field(None, title='Finish Reason')]
+    finish_reason: Annotated[Optional[str], Field(None, title="Finish Reason")]
 
 
 class CreateChatCompletionResponseStreamChoice(BaseModel):
-    index: Annotated[int, Field(title='Index')]
+    index: Annotated[int, Field(title="Index")]
     delta: CreateChatCompletionRequestMessage
-    finish_reason: Annotated[str | None, Field(None, title='Finish Reason')]
+    finish_reason: Annotated[Optional[str], Field(None, title="Finish Reason")]
 
 
 class CreateChatCompletionResponseUsage(BaseModel):
-    prompt_tokens: Annotated[int, Field(title='Prompt Tokens')]
-    completion_tokens: Annotated[int, Field(title='Completion Tokens')]
-    total_tokens: Annotated[int, Field(title='Total Tokens')]
+    prompt_tokens: Annotated[int, Field(title="Prompt Tokens")]
+    completion_tokens: Annotated[int, Field(title="Completion Tokens")]
+    total_tokens: Annotated[int, Field(title="Total Tokens")]
 
 
 class CreateChatCompletionRequest(BaseSchema):
     model_config = ConfigDict(
-        extra='allow',
+        extra="allow",
     )
-    model: Annotated[str | None, Field('gpt-3.5-turbo-16k', title='Model')]
+    model: Annotated[Optional[str], Field("gpt-3.5-turbo-16k", title="Model")]
     messages: Annotated[
-        list[CreateChatCompletionRequestMessage], Field(title='Messages')
+        List[CreateChatCompletionRequestMessage], Field(title="Messages")
     ]
-    temperature: Annotated[float | None, Field(0.9, title='Temperature')]
-    top_p: Annotated[float | None, Field(1.0, title='Top P')]
-    n: Annotated[int | None, Field(1, title='N')]
-    stream: Annotated[bool | None, Field(False, title='Stream')]
-    stop: Annotated[str | list[str] | None, Field(None, title='Stop')]
-    max_tokens: Annotated[int | None, Field(9999, title='Max Tokens')]
-    presence_penalty: Annotated[int | None, Field(0, title='Presence Penalty')]
-    frequency_penalty: Annotated[int | None, Field(0, title='Frequency Penalty')]
-    user: Annotated[str | None, Field(None, title='User')]
+    temperature: Annotated[Optional[float], Field(0.9, title="Temperature")]
+    top_p: Annotated[Optional[float], Field(1.0, title="Top P")]
+    n: Annotated[Optional[int], Field(1, title="N")]
+    stream: Annotated[Optional[bool], Field(False, title="Stream")]
+    stop: Annotated[Optional[Union[str, List[str]]], Field(None, title="Stop")]
+    max_tokens: Annotated[Optional[int], Field(9999, title="Max Tokens")]
+    presence_penalty: Annotated[Optional[int], Field(0, title="Presence Penalty")]
+    frequency_penalty: Annotated[Optional[int], Field(0, title="Frequency Penalty")]
+    user: Annotated[Optional[str], Field(None, title="User")]
     inline_citations: Annotated[
-        Literal["markdown_link", "numbered", "none"],
-        Field('none', title='Type of inline citation formatting.')
-    ] = "markdown_link"
-    journalist_mode: Annotated[bool, Field(True, title=(
-        "Activate journalist mode, with improved alignment for making claims"
-        "with supporting evidence. Improved journalistic style."
-    )
-    )]
-    asknews_watermark: Annotated[bool, Field(
-        True, title='Append "Generated by AskNews AI" watermark')]
-    append_references: Annotated[bool, Field(False, title='Append References or not')]
+        Optional[Literal["markdown_link", "numbered", "none"]],
+        Field("markdown_link", title="Type of inline citation formatting."),
+    ]
+    journalist_mode: Annotated[
+        Optional[bool],
+        Field(
+            True,
+            title=(
+                "Activate journalist mode, with improved alignment for making claims"
+                "with supporting evidence. Improved journalistic style."
+            ),
+        ),
+    ]
+    asknews_watermark: Annotated[
+        Optional[bool], Field(True, title='Append "Generated by AskNews AI" watermark')
+    ]
+    append_references: Annotated[
+        Optional[bool], Field(True, title="Append References or not")
+    ]
 
 
 class CreateChatCompletionResponse(BaseSchema):
-    id: Annotated[str, Field(title='Id')]
-    created: Annotated[int, Field(title='Created')]
-    object: Annotated[str | None, Field('chat.completion', title='Object')]
-    model: Annotated[str | None, Field('gpt-3.5-turbo-16k', title='Model')]
+    id: Annotated[str, Field(title="Id")]
+    created: Annotated[int, Field(title="Created")]
+    object: Annotated[Optional[str], Field("chat.completion", title="Object")]
+    model: Annotated[Optional[str], Field("gpt-3.5-turbo-16k", title="Model")]
     usage: CreateChatCompletionResponseUsage
-    choices: Annotated[list[CreateChatCompletionResponseChoice], Field(title='Choices')]
+    choices: Annotated[List[CreateChatCompletionResponseChoice], Field(title="Choices")]
 
 
 class CreateChatCompletionResponseStream(BaseSchema):
     __content_type__ = "text/event-stream"
 
-    id: Annotated[str, Field(title='Id')]
-    created: Annotated[int, Field(title='Created')]
-    object: Annotated[str | None, Field('chat.completion.chunk', title='Object')]
-    model: Annotated[str | None, Field('gpt-3.5-turbo-16k', title='Model')]
+    id: Annotated[str, Field(title="Id")]
+    created: Annotated[int, Field(title="Created")]
+    object: Annotated[Optional[str], Field("chat.completion.chunk", title="Object")]
+    model: Annotated[Optional[str], Field("gpt-3.5-turbo-16k", title="Model")]
     usage: CreateChatCompletionResponseUsage
     choices: Annotated[
-        list[CreateChatCompletionResponseStreamChoice], Field(title='Choices')
+        List[CreateChatCompletionResponseStreamChoice], Field(title="Choices")
     ]
 
+
 class ModelItem(BaseModel):
-    id: str
-    object: str = "model"
-    created: int = Field(default_factory=lambda: int(datetime.now(timezone.utc).timestamp()))
-    owned_by: str = "asknews"
+    id: Annotated[str, Field(title="Id")]
+    object: Annotated[Optional[str], Field("model", title="Object")]
+    created: Annotated[
+        Optional[int],
+        Field(
+            default_factory=lambda: int(datetime.now(timezone.utc).timestamp()),
+            title="Created",
+        ),
+    ]
+    owned_by: Annotated[Optional[str], Field("asknews", title="Owned By")]
 
 
 class ListModelResponse(BaseSchema):
     __content_type__ = "application/json"
 
-    object: str = "list"
-    data: list[ModelItem]
+    object: Annotated[Optional[str], Field("list", title="Object")]
+    data: Annotated[List[ModelItem], Field(title="Data")]
```

## asknews_sdk/dto/error.py

```diff
@@ -1,18 +1,21 @@
 from __future__ import annotations
-from typing import Annotated
+
+from typing import List, Optional, Union
+
 from pydantic import BaseModel, Field
+from typing_extensions import Annotated
 
 
 class APIErrorModel(BaseModel):
-    code: Annotated[int | None, Field(title='Error Code')] = 500000
-    detail: Annotated[str | None, Field(title='Detail')] = "Internal Server Error"
+    code: Annotated[Optional[int], Field(title="Error Code")] = 500000
+    detail: Annotated[Optional[str], Field(title="Detail")] = "Internal Server Error"
 
 
 class ValidationError(BaseModel):
-    loc: Annotated[list[str | int], Field(title='Location')]
-    msg: Annotated[str, Field(title='Message')]
-    type: Annotated[str, Field(title='Error Type')]
+    loc: Annotated[List[Union[str, int]], Field(title="Location")]
+    msg: Annotated[str, Field(title="Message")]
+    type: Annotated[str, Field(title="Error Type")]
 
 
 class HTTPValidationError(BaseModel):
-    detail: Annotated[list[ValidationError] | None, Field(title='Detail')] = None
+    detail: Annotated[Optional[List[ValidationError]], Field(None, title="Detail")]
```

## asknews_sdk/dto/news.py

```diff
@@ -1,32 +1,34 @@
 from __future__ import annotations
 
-from typing import Annotated
-from pydantic import BaseModel, Field, RootModel
-from datetime import datetime
+from typing import Dict, List, Optional
 
-from asknews_sdk.dto.base import BaseSchema, Article
+from pydantic import AwareDatetime, BaseModel, Field, RootModel
+from typing_extensions import Annotated
+
+from asknews_sdk.dto.base import Article, BaseSchema
 
 
 class SearchResponseDictItem(Article):
-    as_string_key: Annotated[str, Field(title='As String Key')]
+    as_string_key: Annotated[str, Field(title="As String Key")]
 
 
 class SearchResponse(BaseSchema):
     as_dicts: Annotated[
-        list[SearchResponseDictItem] | None, Field(title='As Dicts')
-    ] = None
-    as_string: Annotated[str | None, Field(title='As String')] = None
-    offset: Annotated[int | None, Field(title='Offset Point')] = None
+        Optional[List[SearchResponseDictItem]], Field(None, title="As Dicts")
+    ]
+    as_string: Annotated[Optional[str], Field(None, title="As String")]
+    offset: Annotated[Optional[int], Field(None, title="Offset")]
 
 
 class SourceReportItem(BaseModel):
-    bson_date: Annotated[datetime, Field(title='Bson Date')]
-    n_bucket: Annotated[int, Field(title='Number of Buckets')]
-    n_selected: Annotated[int, Field(title='Number of Selected')]
-    bucket_counts: Annotated[dict[str, int], Field(title='Bucket Counts')]
-    selected_counts: Annotated[dict[str, int], Field(title='Selected Counts')]
-    bucket_pct: Annotated[dict[str, float], Field(title='Bucket Percentage')]
-    selected_pct: Annotated[dict[str, float], Field(title='Selected Percentage')]
+    bson_date: Annotated[AwareDatetime, Field(title="Bson Date")]
+    n_bucket: Annotated[int, Field(title="N Bucket")]
+    n_selected: Annotated[int, Field(title="N Selected")]
+    bucket_counts: Annotated[Dict[str, int], Field(title="Bucket Counts")]
+    selected_counts: Annotated[Dict[str, int], Field(title="Selected Counts")]
+    bucket_pct: Annotated[Dict[str, float], Field(title="Bucket Pct")]
+    selected_pct: Annotated[Dict[str, float], Field(title="Selected Pct")]
+
 
-class SourceReportResponse(BaseSchema, RootModel[list[SourceReportItem]]):
-    root: Annotated[list[SourceReportItem], Field(title='SourceReportResponse')]
+class SourceReportResponse(BaseSchema, RootModel[List[SourceReportItem]]):
+    root: Annotated[List[SourceReportItem], Field(title="SourceReportResponse")]
```

## asknews_sdk/dto/sentiment.py

```diff
@@ -1,21 +1,23 @@
 from __future__ import annotations
 
-from typing import Annotated
+from typing import List
+
 from pydantic import AwareDatetime, BaseModel, Field
+from typing_extensions import Annotated
 
 from asknews_sdk.dto.base import BaseSchema
 
 
 class FinanceResponseTimeSeriesData(BaseModel):
-    datetime: Annotated[AwareDatetime, Field(title='Datetime')]
-    value: Annotated[int, Field(title='Value')]
+    datetime: Annotated[AwareDatetime, Field(title="Datetime")]
+    value: Annotated[int, Field(title="Value")]
 
 
 class FinanceResponseTimeSeries(BaseModel):
     timeseries: Annotated[
-        list[FinanceResponseTimeSeriesData], Field(title='Timeseriesdata')
+        List[FinanceResponseTimeSeriesData], Field(title="Timeseriesdata")
     ]
 
 
 class FinanceResponse(BaseSchema):
     data: FinanceResponseTimeSeries
```

## asknews_sdk/dto/stories.py

```diff
@@ -1,121 +1,135 @@
 from __future__ import annotations
 
-from typing import Annotated
-from datetime import datetime
+from typing import Any, Dict, List, Optional, Union
 from uuid import UUID
-from pydantic import AnyUrl, BaseModel, Field
 
-from asknews_sdk.dto.base import BaseSchema, Article, Entities, RedditEntities
+from pydantic import AnyUrl, AwareDatetime, BaseModel, Field
+from typing_extensions import Annotated
+
+from asknews_sdk.dto.base import Article, BaseSchema, Entities, RedditEntities
 
 
 class RedditPerspective(BaseModel):
-    sentiment: int
-    relevant: bool
-    summary: str
+    sentiment: Annotated[int, Field(title="Sentiment")]
+    relevant: Annotated[bool, Field(title="Relevant")]
+    summary: Annotated[str, Field(title="Summary")]
 
 
 class RedditThread(BaseModel):
-    author: str
-    author_comment_karma: int
-    author_link_karma: int
-    body: str
-    classification: list[str] | str
-    comments: list[RedditComment]
-    comments_count: int
-    date: datetime
+    author: Annotated[str, Field(title="Author")]
+    author_comment_karma: Annotated[int, Field(title="Author Comment Karma")]
+    author_link_karma: Annotated[int, Field(title="Author Link Karma")]
+    body: Annotated[str, Field(title="Body")]
+    classification: Annotated[List[str], Field(title="Classification")]
+    comments: Annotated[List[RedditComment], Field(title="Comments")]
+    comments_count: Annotated[int, Field(title="Comments Count")]
+    date: Annotated[AwareDatetime, Field(title="Date")]
     entities: RedditEntities
-    id: UUID
-    key_takeaways: list[str]
-    keywords: list[str]
-    sentiment: int
-    subreddit_name: str
-    subreddit_url: str
-    summary: str
-    title: str
-    topic: str
-    upvotes: int
-    url: str
+    id: Annotated[UUID, Field(title="Id")]
+    key_takeaways: Annotated[List[str], Field(title="Key Takeaways")]
+    keywords: Annotated[List[str], Field(title="Keywords")]
+    sentiment: Annotated[int, Field(title="Sentiment")]
+    subreddit_name: Annotated[str, Field(title="Subreddit Name")]
+    subreddit_url: Annotated[str, Field(title="Subreddit Url")]
+    summary: Annotated[str, Field(title="Summary")]
+    title: Annotated[str, Field(title="Title")]
+    topic: Annotated[str, Field(title="Topic")]
+    upvotes: Annotated[int, Field(title="Upvotes")]
+    url: Annotated[str, Field(title="Url")]
 
 
 class RedditComment(BaseModel):
-    author: str
-    body: str
-    date: datetime
-    upvotes: int
+    author: Annotated[str, Field(title="Author")]
+    body: Annotated[str, Field(title="Body")]
+    date: Annotated[AwareDatetime, Field(title="Date")]
+    upvotes: Annotated[int, Field(title="Upvotes")]
 
 
 class IntraClusterStatistics(BaseModel):
-    cluster_articles_pct: float = {}
-    cluster_countries_pct: float = {}
-    cluster_domains_pct: float = {}
-    cluster_languages_pct: float = {}
-    cluster_probabilities: dict = {}
+    cluster_articles_pct: Annotated[
+        Optional[float], Field(0.0, title="Cluster Articles Pct")
+    ]
+    cluster_countries_pct: Annotated[
+        Optional[float], Field(0.0, title="Cluster Countries Pct")
+    ]
+    cluster_domains_pct: Annotated[
+        Optional[float], Field(0.0, title="Cluster Domains Pct")
+    ]
+    cluster_languages_pct: Annotated[
+        Optional[float], Field(0.0, title="Cluster Languages Pct")
+    ]
+    cluster_probabilities: Annotated[
+        Optional[Dict[str, Union[int, float]]], Field({}, title="Cluster Probabilities")
+    ]
 
 
 class StoryResponseUpdate(BaseModel):
-    uuid: Annotated[UUID, Field(title='UUID of the story update')]
-    cluster_articles: list[Article]
-    prompt_articles: list[Article]
-    n_articles: int
+    uuid: Annotated[UUID, Field(title="Uuid")]
+    cluster_articles: Annotated[List[Article], Field(title="Cluster Articles")]
+    prompt_articles: Annotated[List[Article], Field(title="Prompt Articles")]
+    n_articles: Annotated[int, Field(title="N Articles")]
     entities: Entities
-    headline: str
-    story: str
-    story_update_ts: int
-    sources_urls: dict[str, int]
-    languages_pct: dict[str, float]
-    countries_pct: dict[str, float]
-    key_takeaways: list[str]
-    contradictions: list[str]
-    continent: str
-    people: list[str]
-    locations: list[str]
-    new_information: str
-    image_url: AnyUrl
-    url_safe_title: str
-    story_uuid: UUID
-    categories: list[str]
-    image_prompt: str
+    headline: Annotated[str, Field(title="Headline")]
+    story: Annotated[str, Field(title="Story")]
+    story_update_ts: Annotated[int, Field(title="Story Update Ts")]
+    sources_urls: Annotated[Dict[str, int], Field(title="Sources Urls")]
+    languages_pct: Annotated[Dict[str, float], Field(title="Languages Pct")]
+    countries_pct: Annotated[Dict[str, float], Field(title="Countries Pct")]
+    key_takeaways: Annotated[List[str], Field(title="Key Takeaways")]
+    contradictions: Annotated[List[str], Field(title="Contradictions")]
+    continent: Annotated[str, Field(title="Continent")]
+    people: Annotated[List[str], Field(title="People")]
+    locations: Annotated[List[str], Field(title="Locations")]
+    new_information: Annotated[str, Field(title="New Information")]
+    image_url: Annotated[AnyUrl, Field(title="Image Url")]
+    url_safe_title: Annotated[str, Field(title="Url Safe Title")]
+    story_uuid: Annotated[UUID, Field(title="Story Uuid")]
+    categories: Annotated[List[str], Field(title="Categories")]
+    image_prompt: Annotated[str, Field(title="Image Prompt")]
     reddit_perspective: RedditPerspective
-    reddit_threads: list[RedditThread]
-    languages: dict[str, int]
-    keywords: list[str]
+    reddit_threads: Annotated[List[RedditThread], Field(title="Reddit Threads")]
+    languages: Annotated[Dict[str, int], Field(title="Languages")]
+    keywords: Annotated[List[str], Field(title="Keywords")]
     intra_cluster_statistics: IntraClusterStatistics
-    silhouette_score: dict
-    article_ids: list[UUID]
-    countries: dict[str, int]
-    markdown_citations: list[str]
-    confidence: float = 0.0
+    silhouette_score: Annotated[Dict[str, Any], Field(title="Silhouette Score")]
+    article_ids: Annotated[List[UUID], Field(title="Article Ids")]
+    countries: Annotated[Dict[str, int], Field(title="Countries")]
+    markdown_citations: Annotated[List[str], Field(title="Markdown Citations")]
+    confidence: Annotated[Optional[float], Field(0.0, title="Confidence")]
+
 
 class StoryResponse(BaseSchema):
-    uuid: Annotated[UUID, Field(title='UUID')]
-    categories: Annotated[list[str], Field(title='Categories')]
-    countries: Annotated[dict[str, int], Field(title='Countries')]
-    countries_pct: Annotated[dict[str, float], Field(title='Countries percentage')]
-    current_update_uuid: Annotated[str, Field(title='Current update UUID')]
-    requested_update_uuid: Annotated[str, Field(title='Requested update UUID')]
-    generate_image: Annotated[bool, Field(title='Generate image flag')]
-    keywords: Annotated[list[str], Field(title='Keywords')]
-    languages: Annotated[dict[str, int], Field(title='Languages')]
-    languages_pct: Annotated[dict[str, float], Field(title='Languages percentage')]
-    locations: Annotated[list[str], Field(title='Locations mentioned')]
-    meta_type: Annotated[str, Field(title='Meta type')]
-    n_articles: Annotated[list[int], Field(title='Number of articles')]
-    n_updates: Annotated[int, Field(title='Number of updates')]
-    people: Annotated[list[str], Field(title='People mentioned')]
-    reddit_sentiment: Annotated[list[int], Field(title='Reddit sentiment')]
-    reddit_sentiment_timestamps: Annotated[list[int], Field(title='Reddit sentiment timestamps')]
-    rolling_sentiment: Annotated[list[float], Field(title='Rolling sentiment')]
-    sentiment: Annotated[list[int], Field(title='Sentiment')]
-    sentiment_timestamps: Annotated[list[int], Field(title='Sentiment timestamps')]
-    sources: Annotated[dict[str, int], Field(title='Sources')]
-    sources_urls: Annotated[dict[str, int], Field(title='Sources URLs')]
-    topic: Annotated[str, Field(title='Topic')]
-    topics: Annotated[list[str], Field(title='Topics')]
-    updates: Annotated[list[StoryResponseUpdate], Field(title='Updates')]
-    updated_ts: Annotated[int, Field(title='Updated timestamp')]
-    update_uuids: Annotated[list[str], Field(title='Update UUIDs')]
+    uuid: Annotated[UUID, Field(title="Uuid")]
+    categories: Annotated[List[str], Field(title="Categories")]
+    countries: Annotated[Dict[str, int], Field(title="Countries")]
+    countries_pct: Annotated[Dict[str, float], Field(title="Countries Pct")]
+    current_update_uuid: Annotated[str, Field(title="Current Update Uuid")]
+    requested_update_uuid: Annotated[str, Field(title="Requested Update Uuid")]
+    generate_image: Annotated[bool, Field(title="Generate Image")]
+    keywords: Annotated[List[str], Field(title="Keywords")]
+    languages: Annotated[Dict[str, int], Field(title="Languages")]
+    languages_pct: Annotated[Dict[str, float], Field(title="Languages Pct")]
+    locations: Annotated[List[str], Field(title="Locations")]
+    meta_type: Annotated[str, Field(title="Meta Type")]
+    n_articles: Annotated[List[int], Field(title="N Articles")]
+    n_updates: Annotated[int, Field(title="N Updates")]
+    people: Annotated[List[str], Field(title="People")]
+    reddit_sentiment: Annotated[List[int], Field(title="Reddit Sentiment")]
+    reddit_sentiment_timestamps: Annotated[
+        List[int], Field(title="Reddit Sentiment Timestamps")
+    ]
+    rolling_sentiment: Annotated[List[float], Field(title="Rolling Sentiment")]
+    sentiment: Annotated[List[int], Field(title="Sentiment")]
+    sentiment_timestamps: Annotated[List[int], Field(title="Sentiment Timestamps")]
+    sources: Annotated[Dict[str, int], Field(title="Sources")]
+    sources_urls: Annotated[Dict[str, int], Field(title="Sources Urls")]
+    topic: Annotated[str, Field(title="Topic")]
+    topics: Annotated[List[str], Field(title="Topics")]
+    updates: Annotated[List[StoryResponseUpdate], Field(title="Updates")]
+    updated_ts: Annotated[int, Field(title="Updated Ts")]
+    update_uuids: Annotated[List[UUID], Field(title="Update Uuids")]
 
 
 class StoriesResponse(BaseSchema):
-    stories: Annotated[list[StoryResponse], Field(title='Stories')]
-    offset: Annotated[int | str | None, Field(title='Offset')]
+    stories: Annotated[List[StoryResponse], Field(title="Stories")]
+    offset: Annotated[Union[int, str], Field(title="Offset")]
```

## asknews_sdk/errors.py

```diff
@@ -1,11 +1,14 @@
+from typing import Optional
+
+
 class APIError(Exception):
     code: int = 500000
 
-    def __init__(self, detail: str, code: int | None = None) -> None:
+    def __init__(self, detail: str, code: Optional[int] = None) -> None:
         self.code = code or self.code
         self.detail = detail
 
     def __str__(self) -> str:
         return f"{self.__class__.__name__}: {self.code} - {self.detail}"
 
 
@@ -29,15 +32,15 @@
     code = 405000
 
 
 class ValidationError(APIError):
     code = 422000
     detail: dict  # type: ignore
 
-    def __init__(self, detail: dict, code: int | None = None) -> None:
+    def __init__(self, detail: dict, code: Optional[int] = None) -> None:
         self.code = code or self.code
         self.detail = detail
 
 
 class ServiceUnavailableError(APIError):
     code = 503000
 
@@ -53,12 +56,13 @@
     404000: ResourceNotFoundError,
     405000: MethodNotAllowed,
     422000: ValidationError,
     500000: APIError,
     503000: ServiceUnavailableError,
 }
 
+
 def raise_from_json(json: dict) -> None:
     code = json.get("code", json.get("status_code", 500) * 1000)
     detail = json.get("detail")
 
     raise ErrorMap.get(code, APIError)(detail, code)
```

## asknews_sdk/sdk.py

```diff
@@ -1,34 +1,36 @@
 from __future__ import annotations
 
-from typing import Any, Callable
+from typing import Any, Callable, Optional, Set
+
 from asgiref.typing import ASGIApplication
 
-from asknews_sdk.dto.base import PingResponse
-from asknews_sdk.client import APIClient, AsyncAPIClient
-from asknews_sdk.security import (
-    TokenLoadHook,
-    TokenSaveHook,
-    AsyncTokenLoadHook,
-    AsyncTokenSaveHook,
-)
 from asknews_sdk.api import (
     AnalyticsAPI,
     AsyncAnalyticsAPI,
-    StoriesAPI,
-    AsyncStoriesAPI,
-    NewsAPI,
+    AsyncChatAPI,
     AsyncNewsAPI,
+    AsyncStoriesAPI,
     ChatAPI,
-    AsyncChatAPI,
+    NewsAPI,
+    StoriesAPI,
+)
+from asknews_sdk.client import APIClient, AsyncAPIClient
+from asknews_sdk.dto.base import PingResponse
+from asknews_sdk.security import (
+    AsyncTokenLoadHook,
+    AsyncTokenSaveHook,
+    TokenLoadHook,
+    TokenSaveHook,
 )
 
 DEFAULT_API_BASE_URL = "https://api.asknews.app"
 DEFAULT_TOKEN_URL = "https://auth.asknews.app/oauth2/token"
 
+
 class AskNewsSDK:
     """
     The AskNews SDK client for communicating with the AskNews API.
 
     Usage:
 
     ```python
@@ -37,54 +39,55 @@
     ```
 
     :param client_id: The client ID for your AskNews API application.
     :type client_id: str
     :param client_secret: The client secret for your AskNews API application.
     :type client_secret: str
     :param scopes: The scopes to request for your AskNews API application.
-    :type scopes: set[str] | None
+    :type scopes: Optional[Set[str]]
     :param base_url: The base URL for the AskNews API.
     :type base_url: str
     :param token_url: The token URL for the AskNews API.
     :type token_url: str
     :param verify_ssl: Whether or not to verify SSL certificates.
     :type verify_ssl: bool
     :param retries: The number of retries to attempt on connection errors.
     :type retries: int
     :param timeout: The timeout for requests.
-    :type timeout: float | None
+    :type timeout: Optional[float]
     """
+
     def __init__(
         self,
         client_id: str,
         client_secret: str,
-        scopes: set[str] | None = None,
+        scopes: Optional[Set[str]] = None,
         base_url: str = DEFAULT_API_BASE_URL,
         token_url: str = DEFAULT_TOKEN_URL,
         verify_ssl: bool = True,
         retries: int = 3,
-        timeout: float | None = None,
+        timeout: Optional[float] = None,
         follow_redirects: bool = True,
-        _mock_server: Callable[..., Any] | None = None,
-        _token_load_hook: TokenLoadHook | None = None,
-        _token_save_hook: TokenSaveHook | None = None
+        _mock_server: Optional[Callable[..., Any]] = None,
+        _token_load_hook: Optional[TokenLoadHook] = None,
+        _token_save_hook: Optional[TokenSaveHook] = None,
     ) -> None:
         self.client = APIClient(
             client_id=client_id,
             client_secret=client_secret,
             scopes=scopes,
             base_url=base_url,
             token_url=token_url,
             verify_ssl=verify_ssl,
             retries=retries,
             timeout=timeout,
             follow_redirects=follow_redirects,
             _mock_server=_mock_server,
             _token_load_hook=_token_load_hook,
-            _token_save_hook=_token_save_hook
+            _token_save_hook=_token_save_hook,
         )
 
         self.analytics = AnalyticsAPI(self.client)
         self.stories = StoriesAPI(self.client)
         self.news = NewsAPI(self.client)
         self.chat = ChatAPI(self.client)
 
@@ -123,54 +126,55 @@
     ```
 
     :param client_id: The client ID for your AskNews API application.
     :type client_id: str
     :param client_secret: The client secret for your AskNews API application.
     :type client_secret: str
     :param scopes: The scopes to request for your AskNews API application.
-    :type scopes: set[str] | None
+    :type scopes: Optional[Set[str]]
     :param base_url: The base URL for the AskNews API.
     :type base_url: str
     :param token_url: The token URL for the AskNews API.
     :type token_url: str
     :param verify_ssl: Whether or not to verify SSL certificates.
     :type verify_ssl: bool
     :param retries: The number of retries to attempt on connection errors.
     :type retries: int
     :param timeout: The timeout for requests.
-    :type timeout: float | None
+    :type timeout: Optional[float]
     """
+
     def __init__(
         self,
         client_id: str,
         client_secret: str,
-        scopes: set[str] | None = None,
+        scopes: Optional[Set[str]] = None,
         base_url: str = DEFAULT_API_BASE_URL,
         token_url: str = DEFAULT_TOKEN_URL,
         verify_ssl: bool = True,
         retries: int = 3,
-        timeout: float | None = None,
+        timeout: Optional[float] = None,
         follow_redirects: bool = True,
-        _mock_server: ASGIApplication | None = None,
-        _token_load_hook: AsyncTokenLoadHook | None = None,
-        _token_save_hook: AsyncTokenSaveHook | None = None
+        _mock_server: Optional[ASGIApplication] = None,
+        _token_load_hook: Optional[AsyncTokenLoadHook] = None,
+        _token_save_hook: Optional[AsyncTokenSaveHook] = None,
     ) -> None:
         self.client = AsyncAPIClient(
             client_id=client_id,
             client_secret=client_secret,
             scopes=scopes,
             base_url=base_url,
             token_url=token_url,
             verify_ssl=verify_ssl,
             retries=retries,
             timeout=timeout,
             follow_redirects=follow_redirects,
             _mock_server=_mock_server,
             _token_load_hook=_token_load_hook,
-            _token_save_hook=_token_save_hook
+            _token_save_hook=_token_save_hook,
         )
 
         self.analytics = AsyncAnalyticsAPI(self.client)
         self.stories = AsyncStoriesAPI(self.client)
         self.news = AsyncNewsAPI(self.client)
         self.chat = AsyncChatAPI(self.client)
```

## asknews_sdk/security.py

```diff
@@ -1,34 +1,36 @@
 from __future__ import annotations
 
-import os
 import base64
 import json
+import os
 import warnings
+from datetime import datetime, timedelta, timezone
 from pathlib import Path
+from typing import Awaitable, Callable, Optional, Union
+
 from anyio import Path as AsyncPath
 from cryptography.fernet import Fernet
-from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
-from cryptography.hazmat.primitives import hashes
 from cryptography.hazmat.backends import default_backend
-from typing import Callable, Awaitable
-from datetime import datetime, timedelta, timezone
-from typing_extensions import TypedDict
+from cryptography.hazmat.primitives import hashes
+from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
 from httpx import Request
+from typing_extensions import TypedDict
+
 
 class TokenInfo(TypedDict):
     access_token: str
     scope: str
     token_type: str
     expires_in: int
 
 
 class OAuthToken:
-    def __init__(self, token_info: TokenInfo = {}) -> None:  # type: ignore
-        self.set_token(token_info)
+    def __init__(self, token_info: Optional[TokenInfo] = None) -> None:  # type: ignore
+        self.set_token(token_info if token_info is not None else {})
 
     def set_token(self, token_info: TokenInfo) -> None:
         self.token_info = token_info
         self._expires_at = datetime.now(timezone.utc) + timedelta(
             seconds=token_info.get("expires_in", 0)
         )
 
@@ -72,40 +74,47 @@
 
 
 TokenLoadHook = Callable[..., TokenInfo]
 TokenSaveHook = Callable[[TokenInfo], None]
 AsyncTokenLoadHook = Callable[..., Awaitable[TokenInfo]]
 AsyncTokenSaveHook = Callable[[TokenInfo], Awaitable[None]]
 
-class SecurityWarning(Warning):
-    ...
+
+class SecurityWarning(Warning): ...
+
 
 def _derive_encryption_key(password: str, salt: bytes) -> bytes:
     kdf = PBKDF2HMAC(
         algorithm=hashes.SHA256(),
         length=32,
         salt=salt,
         iterations=100_000,
         backend=default_backend(),
     )
     return base64.urlsafe_b64encode(kdf.derive(password.encode()))
 
+
 def _encrypt_with_key(key: bytes, data: bytes) -> bytes:
     f = Fernet(key)
     return f.encrypt(data)
 
+
 def _decrypt_with_key(key: bytes, data: bytes) -> bytes:
     f = Fernet(key)
     return f.decrypt(data)
 
 
-def _save_token_disk(file_path: Path | str, client_id: str, client_secret: str) -> TokenSaveHook:
+def _save_token_disk(
+    file_path: Union[Path, str], client_id: str, client_secret: str
+) -> TokenSaveHook:
     warnings.warn(
-        "Saving access tokens to disk is dangerous and should be avoided. Use at your own risk.",
-        SecurityWarning
+        "Saving access tokens to disk is dangerous and should be avoided. "
+        "Use at your own risk.",
+        SecurityWarning,
+        stacklevel=2,
     )
 
     if not isinstance(file_path, Path):
         file_path = Path(file_path)
 
     def _save_token(token: TokenInfo) -> None:
         salt = os.urandom(16)
@@ -113,15 +122,18 @@
 
         serialized_token = json.dumps(token).encode()
         token_info = _encrypt_with_key(key, serialized_token)
         file_path.write_bytes(salt + b"::" + token_info)
 
     return _save_token
 
-def _load_token_disk(file_path: Path, client_id: str, client_secret: str) -> TokenLoadHook:
+
+def _load_token_disk(
+    file_path: Path, client_id: str, client_secret: str
+) -> TokenLoadHook:
     if not isinstance(file_path, Path):
         file_path = Path(file_path)
 
     def _load_token() -> TokenInfo:
         if not file_path.exists():
             return {}
 
@@ -131,22 +143,23 @@
         key = _derive_encryption_key((client_id + client_secret), salt)
         serialized_token = _decrypt_with_key(key, token_info)
 
         return json.loads(serialized_token)
 
     return _load_token
 
+
 def _save_token_disk_async(
-    file_path: Path | AsyncPath | str,
-    client_id: str,
-    client_secret: str
+    file_path: Union[Path, AsyncPath, str], client_id: str, client_secret: str
 ) -> AsyncTokenSaveHook:
     warnings.warn(
-        "Saving access tokens to disk is dangerous and should be avoided. Use at your own risk.",
-        SecurityWarning
+        "Saving access tokens to disk is dangerous and should be avoided. "
+        "Use at your own risk.",
+        SecurityWarning,
+        stacklevel=2,
     )
 
     if not isinstance(file_path, AsyncPath):
         file_path = AsyncPath(file_path)
 
     async def _save_token(token: TokenInfo) -> None:
         salt = os.urandom(16)
@@ -154,18 +167,17 @@
 
         serialized_token = json.dumps(token).encode()
         token_info = _encrypt_with_key(key, serialized_token)
         await file_path.write_bytes(salt + b"::" + token_info)
 
     return _save_token
 
+
 def _load_token_disk_async(
-    file_path: Path | AsyncPath | str,
-    client_id: str,
-    client_secret: str
+    file_path: Union[Path, AsyncPath, str], client_id: str, client_secret: str
 ) -> AsyncTokenLoadHook:
     if not isinstance(file_path, AsyncPath):
         file_path = AsyncPath(file_path)
 
     async def _load_token() -> OAuthToken:
         if not await file_path.exists():
             return {}
```

## asknews_sdk/utils.py

```diff
@@ -1,33 +1,35 @@
-import orjson
-from typing import Any
-from urllib.parse import urljoin, urlencode
 from collections.abc import Iterable
+from typing import Any, List, Optional, Tuple
+from urllib.parse import urlencode, urljoin
+
+import orjson
 
 
 def serialize(data: Any) -> bytes:
     return orjson.dumps(data)
 
+
 def deserialize(data: bytes) -> Any:
     return orjson.loads(data)
 
 
-def build_accept_header(accepted_types: list[tuple[str, float]]) -> str:
+def build_accept_header(accepted_types: List[Tuple[str, float]]) -> str:
     accept_strings = []
     for content_type, quality in accepted_types:
         quality = f"; q={quality}" if quality < 1.0 else ""  # type: ignore
         accept_strings.append(f"{content_type}{quality}")
     return ", ".join(accept_strings)
 
 
 def build_url(
     base_url: str,
     endpoint: str,
-    query: dict | None = None,
-    params: dict | None = None,
+    query: Optional[dict] = None,
+    params: Optional[dict] = None,
 ) -> str:
     params = {k: str(v) for k, v in (params or {}).items()}
     path = endpoint.format(**params)
     url = urljoin(base_url, path)
 
     if query:
         query_parts = []
```

## Comparing `asknews-0.5.5.dist-info/LICENSE` & `asknews-0.6.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `asknews-0.5.5.dist-info/METADATA` & `asknews-0.6.0.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,18 +1,19 @@
 Metadata-Version: 2.1
 Name: asknews
-Version: 0.5.5
+Version: 0.6.0
 Summary: Python SDK for AskNews
 Home-page: https://gitlab.com/emergentmethods/asknews/python-sdk
 License: MIT
 Author: Emergent Methods
 Author-email: contact@emergentmethods.ai
-Requires-Python: >=3.10,<4.0
+Requires-Python: >=3.8.1,<4.0
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Programming Language :: Python :: 3.11
 Classifier: Programming Language :: Python :: 3.12
 Requires-Dist: asgiref (>=3.7.2,<4.0.0)
 Requires-Dist: authlib (>=1.3.0,<2.0.0)
 Requires-Dist: httpx (>=0.25.2,<0.26.0)
 Requires-Dist: orjson (>=3.9.10,<4.0.0)
```

## Comparing `asknews-0.5.5.dist-info/RECORD` & `asknews-0.6.0.dist-info/RECORD`

 * *Files 23% similar despite different names*

```diff
@@ -1,24 +1,24 @@
-asknews_sdk/__init__.py,sha256=7ahSPD_GVDumIhrtqjR9vNC1FJdu-MTWFAe7-6K5WJs,263
-asknews_sdk/api/__init__.py,sha256=giN1hOeU7Csh8gbRGDCrKsLXR5E3mx_vScNNyHaM16M,415
-asknews_sdk/api/analytics.py,sha256=Pdri83YjVS8JkwqDyCYVIlIa0FqL-brrQ2KJm_SniCY,4442
-asknews_sdk/api/base.py,sha256=Zwg4Cy9FDUt2wywKUmVnZIex7NB9oUrdRR0BM8Yll7A,170
-asknews_sdk/api/chat.py,sha256=Mb20BoUfM-yADU7cg2gQQ40fG9-mnmlWH2lcPtTucy8,8437
-asknews_sdk/api/news.py,sha256=GSv_6U4_7uo49ZrUHGseITA2yCj26e0KrqF4ob0g7ig,11705
-asknews_sdk/api/stories.py,sha256=X7pFH0sPej8lrPmuH8hJ9BlCBryyK-nlYYJ_nJfPN8k,10473
-asknews_sdk/client.py,sha256=Lj7akBppXJI7XUNDgkbQhEbcGDP58P5noEA_ncXjeYM,15904
-asknews_sdk/dto/__init__.py,sha256=tNRL7YBHo76LAeTADE9qIj5xR0eQywJHpuer7QSuJXY,740
-asknews_sdk/dto/base.py,sha256=qWmt8bTCSYMFNALZyTEpuQZRu_yesSqJWbJ3maMeqcg,2430
-asknews_sdk/dto/chat.py,sha256=zUo894dPtv9gLrDRCvuFZPSF9FPRJC32ZV3bcuq7cPg,3981
-asknews_sdk/dto/error.py,sha256=XhOo_lgl9vVHbhUVQiFIUXVaXAexUULjr7Hph5b6Ovc,606
-asknews_sdk/dto/news.py,sha256=vI3CC3rljq9I7T5ivp97KZpbvSeJJzel7b5N3qFEqyo,1284
-asknews_sdk/dto/sentiment.py,sha256=m6d-5mQ0dd4vewj7wF3-IZGLknXHkaKRmdYbyUaYI50,552
-asknews_sdk/dto/stories.py,sha256=lqgKFPo3rOWqJeJWQ5UVAKUc-XHfL8h0Jt46vHSAiKg,4200
-asknews_sdk/errors.py,sha256=F7VncOcrCxM1mYGCqV2NUGDnDnqQWgxhhmXd__-5bK8,1414
-asknews_sdk/sdk.py,sha256=ljfgbkpJT5lW-ATx1eVkPI9WyeJwRSdClwL_puHAkyA,6274
-asknews_sdk/security.py,sha256=C3_-lQMwHNx9E-4GC4LedXofJ2ybZLGQGxIh55nVvks,5248
-asknews_sdk/utils.py,sha256=YAk-0ANXWu7J9PlKCyptXZnlvle4cLXuQWXxjxxWojQ,1583
+asknews_sdk/__init__.py,sha256=TSiiLJIi3INZrbhvrqaXBSAG4MuX5e-Hz7VQstvTOWM,262
+asknews_sdk/api/__init__.py,sha256=1pNfLO6CSeU2bapA-l_oyUQhW2bgavSQUdQcWqjzwno,415
+asknews_sdk/api/analytics.py,sha256=XrH5U5GYXJ5RRTQNVkWYnL-HOD-6yLm6HmNNVWKczxQ,4569
+asknews_sdk/api/base.py,sha256=6w20VMcj9wuMIZLSy_ajbGbMs-cHWbyN7easFpNb8Cg,203
+asknews_sdk/api/chat.py,sha256=7EbwsFKwwmT8Q-7HanDaWrNO8p1bBt565uBHpAH91ao,8720
+asknews_sdk/api/news.py,sha256=Qd52srnuS3cvdRAWFh3UYyKPisIFZeeG3mt3wLGa3J0,13185
+asknews_sdk/api/stories.py,sha256=GG_1lJ4S5EoSPO6HRJQIFWXZWSsu54WXKgqufBXz_TU,10988
+asknews_sdk/client.py,sha256=A7irft6UAXEIA8OTC2-EOfp7HSREiT09WAZ7g53iAVM,16134
+asknews_sdk/dto/__init__.py,sha256=dECq34FclMMDeF8Fq62TTngjillmysK8yht2DTOdqHM,677
+asknews_sdk/dto/base.py,sha256=F5rtwwAcuDbCYY1MF0i06IbasIVhZTWzHWoMp4t7f-Y,3805
+asknews_sdk/dto/chat.py,sha256=U76lXLM27LXAxGeMFzbBp9rr5Wi5epXr3H6-2jyZhfc,4530
+asknews_sdk/dto/error.py,sha256=fAJutRBtFzSLcJuZYgTDZtv7-T3p6WBGqk3ky3K481c,674
+asknews_sdk/dto/news.py,sha256=aq9H-lU3LOPbTgPXT_j_7HlCHx-y1aNdPuwD9a6icVo,1296
+asknews_sdk/dto/sentiment.py,sha256=ZK0ArKptbbu7WScZWxavZrONDb5l2o9jlPdrCBF5epg,588
+asknews_sdk/dto/stories.py,sha256=H0TTy1t52NOkTP4mLB1bcDgibPh76_bDhOWV7UCtVw8,6643
+asknews_sdk/errors.py,sha256=2J6fihHeAL1ny7bdGAoEOazaRibosU3N4IFDBlO9vHk,1451
+asknews_sdk/sdk.py,sha256=EMQeZLuPeAWlV8yLbiefY_C7UuG-1pFDp7GwKJ0rsn4,6339
+asknews_sdk/security.py,sha256=mXVyc4_5KE2j-t5fS3IKewUfmCJZLCPbfcXMJJpLzIk,5396
+asknews_sdk/utils.py,sha256=tM7ga0MZGDA4YheH4dyZ6xxVVexMkzTMz0f6ttP6pwU,1614
 asknews_sdk/version.py,sha256=J-j-u0itpEFT6irdmWmixQqYMadNl1X91TxUmoiLHMI,22
-asknews-0.5.5.dist-info/LICENSE,sha256=PphLPr74YBd3DwU0qher5XzGzcSJdOH9MYgApVO6wIo,1073
-asknews-0.5.5.dist-info/METADATA,sha256=JwXtH5RzuHErBTqeGX-p0ZhzEbvxftVJYrKmbEanE6w,3185
-asknews-0.5.5.dist-info/WHEEL,sha256=sP946D7jFCHeNz5Iq4fL4Lu-PrWrFsgfLXbbkciIZwg,88
-asknews-0.5.5.dist-info/RECORD,,
+asknews-0.6.0.dist-info/LICENSE,sha256=PphLPr74YBd3DwU0qher5XzGzcSJdOH9MYgApVO6wIo,1073
+asknews-0.6.0.dist-info/METADATA,sha256=T8YRo5b6bnYHHmw2dPdlsX4cGe9q-0KMWEIOiSj-erk,3236
+asknews-0.6.0.dist-info/WHEEL,sha256=sP946D7jFCHeNz5Iq4fL4Lu-PrWrFsgfLXbbkciIZwg,88
+asknews-0.6.0.dist-info/RECORD,,
```

